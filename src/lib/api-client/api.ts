/* tslint:disable */
/* eslint-disable */
/**
 * DomainFlow API
 * DomainFlow API for domain generation, validation, and campaign management.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@domainflow.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Request to add a proxy to a pool
 * @export
 * @interface AddProxyToPoolRequest
 */
export interface AddProxyToPoolRequest {
    /**
     * Proxy ID to add to the pool
     * @type {string}
     * @memberof AddProxyToPoolRequest
     */
    'proxyId': string;
    /**
     * Weight for weighted pool strategies
     * @type {number}
     * @memberof AddProxyToPoolRequest
     */
    'weight'?: number;
}
/**
 * Authentication configuration
 * @export
 * @interface AuthConfig
 */
export interface AuthConfig {
    /**
     * Account lock duration (e.g., \'15m\')
     * @type {string}
     * @memberof AuthConfig
     */
    'accountLockDuration'?: string;
    /**
     * BCrypt cost factor for password hashing
     * @type {number}
     * @memberof AuthConfig
     */
    'bcryptCost'?: number;
    /**
     * Number of failed attempts before requiring CAPTCHA
     * @type {number}
     * @memberof AuthConfig
     */
    'captchaThreshold'?: number;
    /**
     * From email address for system emails
     * @type {string}
     * @memberof AuthConfig
     */
    'fromEmail'?: string;
    /**
     * From name for system emails
     * @type {string}
     * @memberof AuthConfig
     */
    'fromName'?: string;
    /**
     * Maximum failed login attempts before lockout
     * @type {number}
     * @memberof AuthConfig
     */
    'maxFailedAttempts'?: number;
    /**
     * Maximum login attempts per rate limit window
     * @type {number}
     * @memberof AuthConfig
     */
    'maxLoginAttempts'?: number;
    /**
     * Maximum password reset attempts per rate limit window
     * @type {number}
     * @memberof AuthConfig
     */
    'maxPasswordResetAttempts'?: number;
    /**
     * Minimum password length requirement
     * @type {number}
     * @memberof AuthConfig
     */
    'passwordMinLength'?: number;
    /**
     * Rate limit window (e.g., \'15m\')
     * @type {string}
     * @memberof AuthConfig
     */
    'rateLimitWindow'?: string;
    /**
     * reCAPTCHA site key
     * @type {string}
     * @memberof AuthConfig
     */
    'recaptchaSiteKey'?: string;
    /**
     * Password reset token expiry (e.g., \'15m\')
     * @type {string}
     * @memberof AuthConfig
     */
    'resetTokenExpiry'?: string;
    /**
     * Session cookie domain
     * @type {string}
     * @memberof AuthConfig
     */
    'sessionCookieDomain'?: string;
    /**
     * Session cookie name
     * @type {string}
     * @memberof AuthConfig
     */
    'sessionCookieName'?: string;
    /**
     * Whether session cookie requires HTTPS
     * @type {boolean}
     * @memberof AuthConfig
     */
    'sessionCookieSecure'?: boolean;
    /**
     * Session duration (e.g., \'120m\')
     * @type {string}
     * @memberof AuthConfig
     */
    'sessionDuration'?: string;
    /**
     * Session idle timeout (e.g., \'30m\')
     * @type {string}
     * @memberof AuthConfig
     */
    'sessionIdleTimeout'?: string;
    /**
     * SMTP server host
     * @type {string}
     * @memberof AuthConfig
     */
    'smtpHost'?: string;
    /**
     * SMTP server port
     * @type {number}
     * @memberof AuthConfig
     */
    'smtpPort'?: number;
    /**
     * SMTP username
     * @type {string}
     * @memberof AuthConfig
     */
    'smtpUsername'?: string;
}
/**
 * Request body for batch keyword extraction
 * @export
 * @interface BatchKeywordExtractionRequest
 */
export interface BatchKeywordExtractionRequest {
    /**
     * Array of URLs and parameters for keyword extraction
     * @type {Array<KeywordExtractionRequestItem>}
     * @memberof BatchKeywordExtractionRequest
     */
    'items': Array<KeywordExtractionRequestItem>;
}
/**
 * Response body for batch keyword extraction
 * @export
 * @interface BatchKeywordExtractionResponse
 */
export interface BatchKeywordExtractionResponse {
    /**
     * Array of keyword extraction results
     * @type {Array<KeywordExtractionAPIResult>}
     * @memberof BatchKeywordExtractionResponse
     */
    'results': Array<KeywordExtractionAPIResult>;
}
/**
 * Request to bulk delete campaigns
 * @export
 * @interface BulkDeleteRequest
 */
export interface BulkDeleteRequest {
    /**
     * Array of campaign UUIDs to delete
     * @type {Array<string>}
     * @memberof BulkDeleteRequest
     */
    'campaignIds': Array<string>;
}
/**
 * Response for bulk delete operation
 * @export
 * @interface BulkDeleteResponse
 */
export interface BulkDeleteResponse {
    /**
     * List of error messages for failed deletions
     * @type {Array<string>}
     * @memberof BulkDeleteResponse
     */
    'errors'?: Array<string>;
    /**
     * Number of campaigns that failed to delete
     * @type {number}
     * @memberof BulkDeleteResponse
     */
    'failedDeletions'?: number;
    /**
     * Operation result message
     * @type {string}
     * @memberof BulkDeleteResponse
     */
    'message'?: string;
    /**
     * Number of campaigns successfully deleted
     * @type {number}
     * @memberof BulkDeleteResponse
     */
    'successfulDeletions'?: number;
    /**
     * Total number of campaigns requested for deletion
     * @type {number}
     * @memberof BulkDeleteResponse
     */
    'totalRequested'?: number;
}
/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'avgProcessingRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'businessStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'campaignType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'completedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'currentPhase'?: string;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'dnsValidatedDomains'?: number;
    /**
     * 
     * @type {DNSValidationCampaignParams}
     * @memberof Campaign
     */
    'dnsValidationParams'?: DNSValidationCampaignParams;
    /**
     * 
     * @type {DomainGenerationCampaignParams}
     * @memberof Campaign
     */
    'domainGenerationParams'?: DomainGenerationCampaignParams;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'domains'?: number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'errorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'estimatedCompletionAt'?: string;
    /**
     * 
     * @type {Array<ExtractedContentItem>}
     * @memberof Campaign
     */
    'extractedContent'?: Array<ExtractedContentItem>;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'failedItems'?: number;
    /**
     * 
     * @type {HTTPKeywordCampaignParams}
     * @memberof Campaign
     */
    'httpKeywordValidationParams'?: HTTPKeywordCampaignParams;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'lastHeartbeatAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Campaign
     */
    'launchSequence'?: boolean;
    /**
     * 
     * @type {Array<LeadItem>}
     * @memberof Campaign
     */
    'leadItems'?: Array<LeadItem>;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'leads'?: number;
    /**
     * 
     * @type {object}
     * @memberof Campaign
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'phaseStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'processedItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'progress'?: number;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'progressPercentage'?: number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'startedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'successfulItems'?: number;
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'totalItems'?: number;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'userId'?: string;
}
/**
 * Campaign details with type-specific parameters
 * @export
 * @interface CampaignDetailsResponse
 */
export interface CampaignDetailsResponse {
    /**
     * 
     * @type {Campaign}
     * @memberof CampaignDetailsResponse
     */
    'campaign'?: Campaign;
    /**
     * Type-specific campaign parameters
     * @type {object}
     * @memberof CampaignDetailsResponse
     */
    'params'?: object;
}
/**
 * Response for campaign list with pagination metadata
 * @export
 * @interface CampaignListResponse
 */
export interface CampaignListResponse {
    /**
     * 
     * @type {Array<Campaign>}
     * @memberof CampaignListResponse
     */
    'data'?: Array<Campaign>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof CampaignListResponse
     */
    'metadata'?: PaginationMetadata;
    /**
     * 
     * @type {string}
     * @memberof CampaignListResponse
     */
    'status'?: CampaignListResponseStatusEnum;
}

export const CampaignListResponseStatusEnum = {
    Success: 'success'
} as const;

export type CampaignListResponseStatusEnum = typeof CampaignListResponseStatusEnum[keyof typeof CampaignListResponseStatusEnum];

/**
 * Response for campaign operations
 * @export
 * @interface CampaignOperationResponse
 */
export interface CampaignOperationResponse {
    /**
     * Campaign ID
     * @type {string}
     * @memberof CampaignOperationResponse
     */
    'campaign_id'?: string;
    /**
     * Operation result message
     * @type {string}
     * @memberof CampaignOperationResponse
     */
    'message'?: string;
}
/**
 * Password change request
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * Current password
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'currentPassword': string;
    /**
     * New password (minimum 12 characters)
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword': string;
}
/**
 * Status of a single component
 * @export
 * @interface ComponentStatus
 */
export interface ComponentStatus {
    /**
     * Optional status message
     * @type {string}
     * @memberof ComponentStatus
     */
    'message'?: string;
    /**
     * Component status
     * @type {string}
     * @memberof ComponentStatus
     */
    'status': ComponentStatusStatusEnum;
    /**
     * Status check timestamp
     * @type {string}
     * @memberof ComponentStatus
     */
    'timestamp': string;
}

export const ComponentStatusStatusEnum = {
    Ok: 'ok',
    Error: 'error'
} as const;

export type ComponentStatusStatusEnum = typeof ComponentStatusStatusEnum[keyof typeof ComponentStatusStatusEnum];

/**
 * Cookie handling configuration
 * @export
 * @interface CookieHandling
 */
export interface CookieHandling {
    /**
     * Cookie handling mode
     * @type {string}
     * @memberof CookieHandling
     */
    'mode'?: CookieHandlingModeEnum;
}

export const CookieHandlingModeEnum = {
    Preserve: 'preserve',
    Ignore: 'ignore',
    Custom: 'custom',
    Clear: 'clear',
    SessionOnly: 'session_only'
} as const;

export type CookieHandlingModeEnum = typeof CookieHandlingModeEnum[keyof typeof CookieHandlingModeEnum];

/**
 * Request to create a new campaign
 * @export
 * @interface CreateCampaignRequest
 */
export interface CreateCampaignRequest {
    /**
     * Type of campaign to create
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'campaignType': CreateCampaignRequestCampaignTypeEnum;
    /**
     * Campaign description
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'description'?: string;
    /**
     * 
     * @type {DnsValidationParams}
     * @memberof CreateCampaignRequest
     */
    'dnsValidationParams'?: DnsValidationParams;
    /**
     * 
     * @type {DomainGenerationParams}
     * @memberof CreateCampaignRequest
     */
    'domainGenerationParams'?: DomainGenerationParams;
    /**
     * 
     * @type {HttpKeywordParams}
     * @memberof CreateCampaignRequest
     */
    'httpKeywordParams'?: HttpKeywordParams;
    /**
     * Campaign name
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'name': string;
    /**
     * User ID creating the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'userId'?: string;
}

export const CreateCampaignRequestCampaignTypeEnum = {
    DomainGeneration: 'domain_generation',
    DnsValidation: 'dns_validation',
    HttpKeywordValidation: 'http_keyword_validation'
} as const;

export type CreateCampaignRequestCampaignTypeEnum = typeof CreateCampaignRequestCampaignTypeEnum[keyof typeof CreateCampaignRequestCampaignTypeEnum];

/**
 * Request to create a new keyword set
 * @export
 * @interface CreateKeywordSetRequest
 */
export interface CreateKeywordSetRequest {
    /**
     * Keyword set description
     * @type {string}
     * @memberof CreateKeywordSetRequest
     */
    'description'?: string;
    /**
     * Whether the keyword set is enabled
     * @type {boolean}
     * @memberof CreateKeywordSetRequest
     */
    'isEnabled'?: boolean;
    /**
     * Keyword set name
     * @type {string}
     * @memberof CreateKeywordSetRequest
     */
    'name': string;
    /**
     * List of keyword rules to include in the set
     * @type {Array<KeywordRuleRequest>}
     * @memberof CreateKeywordSetRequest
     */
    'rules'?: Array<KeywordRuleRequest>;
}
/**
 * Request to create a new persona
 * @export
 * @interface CreatePersonaRequest
 */
export interface CreatePersonaRequest {
    /**
     * 
     * @type {CreatePersonaRequestConfigDetails}
     * @memberof CreatePersonaRequest
     */
    'configDetails': CreatePersonaRequestConfigDetails;
    /**
     * Persona description
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'description'?: string;
    /**
     * Whether the persona is enabled
     * @type {boolean}
     * @memberof CreatePersonaRequest
     */
    'isEnabled'?: boolean;
    /**
     * Persona name
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'name': string;
    /**
     * Type of persona
     * @type {string}
     * @memberof CreatePersonaRequest
     */
    'personaType': CreatePersonaRequestPersonaTypeEnum;
}

export const CreatePersonaRequestPersonaTypeEnum = {
    Dns: 'dns',
    Http: 'http'
} as const;

export type CreatePersonaRequestPersonaTypeEnum = typeof CreatePersonaRequestPersonaTypeEnum[keyof typeof CreatePersonaRequestPersonaTypeEnum];

/**
 * @type CreatePersonaRequestConfigDetails
 * Type-specific configuration details
 * @export
 */
export type CreatePersonaRequestConfigDetails = DnsPersonaConfig | HttpPersonaConfig;

/**
 * Request to create a new proxy
 * @export
 * @interface CreateProxyRequest
 */
export interface CreateProxyRequest {
    /**
     * Proxy address (host:port)
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'address': string;
    /**
     * Country code for the proxy location
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'countryCode'?: string;
    /**
     * Proxy description
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'description'?: string;
    /**
     * Whether the proxy is enabled
     * @type {boolean}
     * @memberof CreateProxyRequest
     */
    'isEnabled'?: boolean;
    /**
     * Proxy name
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'name': string;
    /**
     * Proxy password for authentication
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'password'?: string;
    /**
     * Proxy protocol
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'protocol': CreateProxyRequestProtocolEnum;
    /**
     * Proxy username for authentication
     * @type {string}
     * @memberof CreateProxyRequest
     */
    'username'?: string;
}

export const CreateProxyRequestProtocolEnum = {
    Http: 'http',
    Https: 'https',
    Socks5: 'socks5',
    Socks4: 'socks4'
} as const;

export type CreateProxyRequestProtocolEnum = typeof CreateProxyRequestProtocolEnum[keyof typeof CreateProxyRequestProtocolEnum];

/**
 * DNS validator configuration
 * @export
 * @interface DNSConfig
 */
export interface DNSConfig {
    /**
     * Concurrent queries per domain
     * @type {number}
     * @memberof DNSConfig
     */
    'concurrentQueriesPerDomain'?: number;
    /**
     * Maximum concurrent goroutines
     * @type {number}
     * @memberof DNSConfig
     */
    'maxConcurrentGoroutines'?: number;
    /**
     * Maximum domains per request
     * @type {number}
     * @memberof DNSConfig
     */
    'maxDomainsPerRequest'?: number;
    /**
     * Maximum query delay in milliseconds
     * @type {number}
     * @memberof DNSConfig
     */
    'queryDelayMaxMs'?: number;
    /**
     * Minimum query delay in milliseconds
     * @type {number}
     * @memberof DNSConfig
     */
    'queryDelayMinMs'?: number;
    /**
     * DNS query timeout in seconds
     * @type {number}
     * @memberof DNSConfig
     */
    'queryTimeoutSeconds'?: number;
    /**
     * Rate limit burst capacity
     * @type {number}
     * @memberof DNSConfig
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in queries per second
     * @type {number}
     * @memberof DNSConfig
     */
    'rateLimitDps'?: number;
    /**
     * Strategy for selecting DNS resolvers
     * @type {string}
     * @memberof DNSConfig
     */
    'resolverStrategy'?: DNSConfigResolverStrategyEnum;
    /**
     * DNS resolver IP addresses
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    'resolvers'?: Array<string>;
    /**
     * Preferred order of resolvers
     * @type {Array<string>}
     * @memberof DNSConfig
     */
    'resolversPreferredOrder'?: Array<string>;
    /**
     * Weighted resolver configuration
     * @type {{ [key: string]: number; }}
     * @memberof DNSConfig
     */
    'resolversWeighted'?: { [key: string]: number; };
    /**
     * Use system DNS resolvers
     * @type {boolean}
     * @memberof DNSConfig
     */
    'useSystemResolvers'?: boolean;
}

export const DNSConfigResolverStrategyEnum = {
    RoundRobin: 'round_robin',
    Random: 'random',
    Weighted: 'weighted',
    Priority: 'priority'
} as const;

export type DNSConfigResolverStrategyEnum = typeof DNSConfigResolverStrategyEnum[keyof typeof DNSConfigResolverStrategyEnum];

/**
 * DNS persona configuration details
 * @export
 * @interface DNSConfigDetails
 */
export interface DNSConfigDetails {
    /**
     * Concurrent queries per domain
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'concurrentQueriesPerDomain'?: number;
    /**
     * Maximum concurrent goroutines
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'maxConcurrentGoroutines'?: number;
    /**
     * Maximum domains per request
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'maxDomainsPerRequest'?: number;
    /**
     * Maximum query delay in milliseconds
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'queryDelayMaxMs'?: number;
    /**
     * Minimum query delay in milliseconds
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'queryDelayMinMs'?: number;
    /**
     * Query timeout in seconds
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'queryTimeoutSeconds'?: number;
    /**
     * Rate limit burst size
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in domains per second
     * @type {number}
     * @memberof DNSConfigDetails
     */
    'rateLimitDps'?: number;
    /**
     * Resolver selection strategy
     * @type {string}
     * @memberof DNSConfigDetails
     */
    'resolverStrategy'?: DNSConfigDetailsResolverStrategyEnum;
    /**
     * DNS resolver addresses
     * @type {Array<string>}
     * @memberof DNSConfigDetails
     */
    'resolvers'?: Array<string>;
    /**
     * Whether to use system resolvers
     * @type {boolean}
     * @memberof DNSConfigDetails
     */
    'useSystemResolvers'?: boolean;
}

export const DNSConfigDetailsResolverStrategyEnum = {
    RoundRobin: 'round_robin',
    Random: 'random',
    Weighted: 'weighted',
    Priority: 'priority'
} as const;

export type DNSConfigDetailsResolverStrategyEnum = typeof DNSConfigDetailsResolverStrategyEnum[keyof typeof DNSConfigDetailsResolverStrategyEnum];

/**
 * 
 * @export
 * @interface DNSValidationCampaignParams
 */
export interface DNSValidationCampaignParams {
    /**
     * 
     * @type {number}
     * @memberof DNSValidationCampaignParams
     */
    'batchSize'?: number;
    /**
     * 
     * @type {object}
     * @memberof DNSValidationCampaignParams
     */
    'metadata'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof DNSValidationCampaignParams
     */
    'personaIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DNSValidationCampaignParams
     */
    'processingSpeedPerMinute'?: number;
    /**
     * 
     * @type {number}
     * @memberof DNSValidationCampaignParams
     */
    'retryAttempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof DNSValidationCampaignParams
     */
    'rotationIntervalSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof DNSValidationCampaignParams
     */
    'sourceGenerationCampaignId'?: string;
}
/**
 * DNS validation result information
 * @export
 * @interface DNSValidationResult
 */
export interface DNSValidationResult {
    /**
     * Number of validation attempts
     * @type {number}
     * @memberof DNSValidationResult
     */
    'attempts'?: number;
    /**
     * Business status
     * @type {string}
     * @memberof DNSValidationResult
     */
    'businessStatus'?: string;
    /**
     * Record creation timestamp
     * @type {string}
     * @memberof DNSValidationResult
     */
    'createdAt'?: string;
    /**
     * DNS campaign ID
     * @type {string}
     * @memberof DNSValidationResult
     */
    'dnsCampaignId'?: string;
    /**
     * DNS records found
     * @type {object}
     * @memberof DNSValidationResult
     */
    'dnsRecords'?: object;
    /**
     * Domain name validated
     * @type {string}
     * @memberof DNSValidationResult
     */
    'domainName'?: string;
    /**
     * Generated domain ID
     * @type {string}
     * @memberof DNSValidationResult
     */
    'generatedDomainId'?: string;
    /**
     * Result unique identifier
     * @type {string}
     * @memberof DNSValidationResult
     */
    'id'?: string;
    /**
     * Last validation timestamp
     * @type {string}
     * @memberof DNSValidationResult
     */
    'lastCheckedAt'?: string;
    /**
     * Persona used for validation
     * @type {string}
     * @memberof DNSValidationResult
     */
    'validatedByPersonaId'?: string;
    /**
     * Validation status
     * @type {string}
     * @memberof DNSValidationResult
     */
    'validationStatus'?: DNSValidationResultValidationStatusEnum;
}

export const DNSValidationResultValidationStatusEnum = {
    Pending: 'pending',
    Valid: 'valid',
    Invalid: 'invalid',
    Error: 'error',
    Skipped: 'skipped'
} as const;

export type DNSValidationResultValidationStatusEnum = typeof DNSValidationResultValidationStatusEnum[keyof typeof DNSValidationResultValidationStatusEnum];

/**
 * Response for DNS validation results
 * @export
 * @interface DNSValidationResultsResponse
 */
export interface DNSValidationResultsResponse {
    /**
     * 
     * @type {Array<DNSValidationResult>}
     * @memberof DNSValidationResultsResponse
     */
    'data'?: Array<DNSValidationResult>;
    /**
     * Next cursor for pagination
     * @type {string}
     * @memberof DNSValidationResultsResponse
     */
    'nextCursor'?: string;
    /**
     * Total number of DNS validation results
     * @type {number}
     * @memberof DNSValidationResultsResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface DeleteProxyPool200Response
 */
export interface DeleteProxyPool200Response {
    /**
     * Deletion status
     * @type {boolean}
     * @memberof DeleteProxyPool200Response
     */
    'deleted'?: boolean;
}
/**
 * DNS persona configuration details
 * @export
 * @interface DnsPersonaConfig
 */
export interface DnsPersonaConfig {
    /**
     * Concurrent queries per domain
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'concurrentQueriesPerDomain'?: number;
    /**
     * Maximum concurrent goroutines
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'maxConcurrentGoroutines'?: number;
    /**
     * Maximum domains per request
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'maxDomainsPerRequest': number;
    /**
     * Maximum query delay in milliseconds
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'queryDelayMaxMs'?: number;
    /**
     * Minimum query delay in milliseconds
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'queryDelayMinMs'?: number;
    /**
     * DNS query timeout in seconds
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'queryTimeoutSeconds': number;
    /**
     * Rate limit burst capacity
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in queries per second
     * @type {number}
     * @memberof DnsPersonaConfig
     */
    'rateLimitDps'?: number;
    /**
     * Strategy for selecting DNS resolvers
     * @type {string}
     * @memberof DnsPersonaConfig
     */
    'resolverStrategy': DnsPersonaConfigResolverStrategyEnum;
    /**
     * DNS resolver IP addresses
     * @type {Array<string>}
     * @memberof DnsPersonaConfig
     */
    'resolvers': Array<string>;
    /**
     * Preferred order of resolvers
     * @type {Array<string>}
     * @memberof DnsPersonaConfig
     */
    'resolversPreferredOrder'?: Array<string>;
    /**
     * Weighted resolver configuration
     * @type {{ [key: string]: number; }}
     * @memberof DnsPersonaConfig
     */
    'resolversWeighted'?: { [key: string]: number; };
    /**
     * Use system DNS resolvers
     * @type {boolean}
     * @memberof DnsPersonaConfig
     */
    'useSystemResolvers'?: boolean;
}

export const DnsPersonaConfigResolverStrategyEnum = {
    RoundRobin: 'round_robin',
    Random: 'random',
    Weighted: 'weighted',
    Priority: 'priority'
} as const;

export type DnsPersonaConfigResolverStrategyEnum = typeof DnsPersonaConfigResolverStrategyEnum[keyof typeof DnsPersonaConfigResolverStrategyEnum];

/**
 * Parameters for DNS validation campaigns
 * @export
 * @interface DnsValidationParams
 */
export interface DnsValidationParams {
    /**
     * Batch size for processing
     * @type {number}
     * @memberof DnsValidationParams
     */
    'batchSize'?: number;
    /**
     * DNS personas to use for validation
     * @type {Array<string>}
     * @memberof DnsValidationParams
     */
    'personaIds': Array<string>;
    /**
     * Processing speed per minute
     * @type {number}
     * @memberof DnsValidationParams
     */
    'processingSpeedPerMinute'?: number;
    /**
     * Number of retry attempts
     * @type {number}
     * @memberof DnsValidationParams
     */
    'retryAttempts'?: number;
    /**
     * Persona rotation interval in seconds
     * @type {number}
     * @memberof DnsValidationParams
     */
    'rotationIntervalSeconds'?: number;
    /**
     * Source domain generation campaign ID
     * @type {string}
     * @memberof DnsValidationParams
     */
    'sourceCampaignId': string;
}
/**
 * 
 * @export
 * @interface DomainGenerationCampaignParams
 */
export interface DomainGenerationCampaignParams {
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'characterSet'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'constantString'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainGenerationCampaignParams
     */
    'currentOffset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DomainGenerationCampaignParams
     */
    'numDomainsToGenerate'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'patternType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'tld'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainGenerationCampaignParams
     */
    'totalPossibleCombinations'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainGenerationCampaignParams
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof DomainGenerationCampaignParams
     */
    'variableLength'?: number;
}
/**
 * Parameters for domain generation campaigns
 * @export
 * @interface DomainGenerationParams
 */
export interface DomainGenerationParams {
    /**
     * Character set for generation
     * @type {string}
     * @memberof DomainGenerationParams
     */
    'characterSet': string;
    /**
     * Constant string portion
     * @type {string}
     * @memberof DomainGenerationParams
     */
    'constantString': string;
    /**
     * Number of domains to generate
     * @type {number}
     * @memberof DomainGenerationParams
     */
    'numDomainsToGenerate'?: number;
    /**
     * Pattern type for domain generation
     * @type {string}
     * @memberof DomainGenerationParams
     */
    'patternType': DomainGenerationParamsPatternTypeEnum;
    /**
     * Top-level domain
     * @type {string}
     * @memberof DomainGenerationParams
     */
    'tld': string;
    /**
     * Length of variable portion
     * @type {number}
     * @memberof DomainGenerationParams
     */
    'variableLength': number;
}

export const DomainGenerationParamsPatternTypeEnum = {
    PrefixVariable: 'prefix_variable',
    SuffixVariable: 'suffix_variable',
    BothVariable: 'both_variable'
} as const;

export type DomainGenerationParamsPatternTypeEnum = typeof DomainGenerationParamsPatternTypeEnum[keyof typeof DomainGenerationParamsPatternTypeEnum];

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ExtractedContentAnalysis
 */
export interface ExtractedContentAnalysis {
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtractedContentAnalysis
     */
    'advancedKeywords'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExtractedContentAnalysis
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentAnalysis
     */
    'sentiment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentAnalysis
     */
    'summary'?: string;
}
/**
 * 
 * @export
 * @interface ExtractedContentItem
 */
export interface ExtractedContentItem {
    /**
     * 
     * @type {ExtractedContentAnalysis}
     * @memberof ExtractedContentItem
     */
    'advancedAnalysis'?: ExtractedContentAnalysis;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentItem
     */
    'previousCampaignId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExtractedContentItem
     */
    'similarityScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentItem
     */
    'sourceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtractedContentItem
     */
    'text'?: string;
}
/**
 * Feature flag settings
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * Enable analytics feature
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'enableAnalytics'?: boolean;
    /**
     * Enable debug mode feature
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'enableDebugMode'?: boolean;
    /**
     * Enable offline mode feature
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'enableOfflineMode'?: boolean;
    /**
     * Enable real-time updates feature
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'enableRealTimeUpdates'?: boolean;
}
/**
 * 
 * @export
 * @interface ForceCheckAllProxies202Response
 */
export interface ForceCheckAllProxies202Response {
    /**
     * Status message
     * @type {string}
     * @memberof ForceCheckAllProxies202Response
     */
    'message'?: string;
}
/**
 * Request to force health check on specific proxies
 * @export
 * @interface ForceCheckProxiesRequest
 */
export interface ForceCheckProxiesRequest {
    /**
     * List of proxy IDs to check (empty for all)
     * @type {Array<string>}
     * @memberof ForceCheckProxiesRequest
     */
    'ids'?: Array<string>;
}
/**
 * Generated domain information
 * @export
 * @interface GeneratedDomain
 */
export interface GeneratedDomain {
    /**
     * Record creation timestamp
     * @type {string}
     * @memberof GeneratedDomain
     */
    'createdAt'?: string;
    /**
     * DNS resolved IP address
     * @type {string}
     * @memberof GeneratedDomain
     */
    'dnsIp'?: string;
    /**
     * DNS validation status
     * @type {string}
     * @memberof GeneratedDomain
     */
    'dnsStatus'?: GeneratedDomainDnsStatusEnum;
    /**
     * Generated domain name
     * @type {string}
     * @memberof GeneratedDomain
     */
    'domainName'?: string;
    /**
     * Domain generation timestamp
     * @type {string}
     * @memberof GeneratedDomain
     */
    'generatedAt'?: string;
    /**
     * Generation campaign ID
     * @type {string}
     * @memberof GeneratedDomain
     */
    'generationCampaignId'?: string;
    /**
     * HTTP keywords found
     * @type {string}
     * @memberof GeneratedDomain
     */
    'httpKeywords'?: string;
    /**
     * HTTP validation status
     * @type {string}
     * @memberof GeneratedDomain
     */
    'httpStatus'?: GeneratedDomainHttpStatusEnum;
    /**
     * HTTP response status code
     * @type {number}
     * @memberof GeneratedDomain
     */
    'httpStatusCode'?: number;
    /**
     * HTTP page title
     * @type {string}
     * @memberof GeneratedDomain
     */
    'httpTitle'?: string;
    /**
     * Domain unique identifier
     * @type {string}
     * @memberof GeneratedDomain
     */
    'id'?: string;
    /**
     * Last validation timestamp
     * @type {string}
     * @memberof GeneratedDomain
     */
    'lastValidatedAt'?: string;
    /**
     * Lead quality score
     * @type {number}
     * @memberof GeneratedDomain
     */
    'leadScore'?: number;
    /**
     * Offset index in generation space
     * @type {number}
     * @memberof GeneratedDomain
     */
    'offsetIndex'?: number;
    /**
     * Source keyword used for generation
     * @type {string}
     * @memberof GeneratedDomain
     */
    'sourceKeyword'?: string;
    /**
     * Source pattern used for generation
     * @type {string}
     * @memberof GeneratedDomain
     */
    'sourcePattern'?: string;
    /**
     * Top-level domain
     * @type {string}
     * @memberof GeneratedDomain
     */
    'tld'?: string;
}

export const GeneratedDomainDnsStatusEnum = {
    Pending: 'pending',
    Ok: 'ok',
    Error: 'error',
    Timeout: 'timeout'
} as const;

export type GeneratedDomainDnsStatusEnum = typeof GeneratedDomainDnsStatusEnum[keyof typeof GeneratedDomainDnsStatusEnum];
export const GeneratedDomainHttpStatusEnum = {
    Pending: 'pending',
    Ok: 'ok',
    Error: 'error',
    Timeout: 'timeout'
} as const;

export type GeneratedDomainHttpStatusEnum = typeof GeneratedDomainHttpStatusEnum[keyof typeof GeneratedDomainHttpStatusEnum];

/**
 * Response for generated domains
 * @export
 * @interface GeneratedDomainsResponse
 */
export interface GeneratedDomainsResponse {
    /**
     * 
     * @type {Array<GeneratedDomain>}
     * @memberof GeneratedDomainsResponse
     */
    'data'?: Array<GeneratedDomain>;
    /**
     * Next cursor for pagination
     * @type {number}
     * @memberof GeneratedDomainsResponse
     */
    'nextCursor'?: number;
    /**
     * Total number of generated domains
     * @type {number}
     * @memberof GeneratedDomainsResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface GetDomainGenerationPatternOffset200Response
 */
export interface GetDomainGenerationPatternOffset200Response {
    /**
     * Current global offset for this pattern signature
     * @type {number}
     * @memberof GetDomainGenerationPatternOffset200Response
     */
    'currentOffset': number;
}
/**
 * HTTP/2 settings configuration
 * @export
 * @interface HTTP2SettingsConfig
 */
export interface HTTP2SettingsConfig {
    /**
     * Enable HTTP/2
     * @type {boolean}
     * @memberof HTTP2SettingsConfig
     */
    'enabled'?: boolean;
}
/**
 * HTTP validator configuration
 * @export
 * @interface HTTPConfig
 */
export interface HTTPConfig {
    /**
     * Allow insecure TLS connections
     * @type {boolean}
     * @memberof HTTPConfig
     */
    'allowInsecureTLS'?: boolean;
    /**
     * Default HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof HTTPConfig
     */
    'defaultHeaders'?: { [key: string]: string; };
    /**
     * Default User-Agent string for HTTP requests
     * @type {string}
     * @memberof HTTPConfig
     */
    'defaultUserAgent'?: string;
    /**
     * Whether to follow HTTP redirects
     * @type {boolean}
     * @memberof HTTPConfig
     */
    'followRedirects'?: boolean;
    /**
     * Maximum bytes to read from response body
     * @type {number}
     * @memberof HTTPConfig
     */
    'maxBodyReadBytes'?: number;
    /**
     * Maximum concurrent goroutines
     * @type {number}
     * @memberof HTTPConfig
     */
    'maxConcurrentGoroutines'?: number;
    /**
     * Maximum domains per request
     * @type {number}
     * @memberof HTTPConfig
     */
    'maxDomainsPerRequest'?: number;
    /**
     * Maximum number of redirects to follow
     * @type {number}
     * @memberof HTTPConfig
     */
    'maxRedirects'?: number;
    /**
     * Rate limit burst capacity
     * @type {number}
     * @memberof HTTPConfig
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in requests per second
     * @type {number}
     * @memberof HTTPConfig
     */
    'rateLimitDps'?: number;
    /**
     * Request timeout in seconds
     * @type {number}
     * @memberof HTTPConfig
     */
    'requestTimeoutSeconds'?: number;
    /**
     * List of User-Agent strings to rotate through
     * @type {Array<string>}
     * @memberof HTTPConfig
     */
    'userAgents'?: Array<string>;
}
/**
 * HTTP persona configuration details
 * @export
 * @interface HTTPConfigDetails
 */
export interface HTTPConfigDetails {
    /**
     * Allowed HTTP status codes
     * @type {Array<number>}
     * @memberof HTTPConfigDetails
     */
    'allowedStatusCodes'?: Array<number>;
    /**
     * 
     * @type {HTTPCookieHandling}
     * @memberof HTTPConfigDetails
     */
    'cookieHandling'?: HTTPCookieHandling;
    /**
     * Whether to follow redirects
     * @type {boolean}
     * @memberof HTTPConfigDetails
     */
    'followRedirects'?: boolean;
    /**
     * Order of HTTP headers
     * @type {Array<string>}
     * @memberof HTTPConfigDetails
     */
    'headerOrder'?: Array<string>;
    /**
     * HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof HTTPConfigDetails
     */
    'headers'?: { [key: string]: string; };
    /**
     * Configuration notes
     * @type {string}
     * @memberof HTTPConfigDetails
     */
    'notes'?: string;
    /**
     * Rate limit burst size
     * @type {number}
     * @memberof HTTPConfigDetails
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in requests per second
     * @type {number}
     * @memberof HTTPConfigDetails
     */
    'rateLimitDps'?: number;
    /**
     * Request timeout in seconds
     * @type {number}
     * @memberof HTTPConfigDetails
     */
    'requestTimeoutSeconds'?: number;
    /**
     * User agent string
     * @type {string}
     * @memberof HTTPConfigDetails
     */
    'userAgent'?: string;
}
/**
 * HTTP cookie handling configuration
 * @export
 * @interface HTTPCookieHandling
 */
export interface HTTPCookieHandling {
    /**
     * Cookie handling mode
     * @type {string}
     * @memberof HTTPCookieHandling
     */
    'mode'?: HTTPCookieHandlingModeEnum;
}

export const HTTPCookieHandlingModeEnum = {
    Preserve: 'preserve',
    Ignore: 'ignore',
    Custom: 'custom'
} as const;

export type HTTPCookieHandlingModeEnum = typeof HTTPCookieHandlingModeEnum[keyof typeof HTTPCookieHandlingModeEnum];

/**
 * 
 * @export
 * @interface HTTPKeywordCampaignParams
 */
export interface HTTPKeywordCampaignParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof HTTPKeywordCampaignParams
     */
    'adHocKeywords'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof HTTPKeywordCampaignParams
     */
    'batchSize'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof HTTPKeywordCampaignParams
     */
    'keywordSetIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HTTPKeywordCampaignParams
     */
    'lastProcessedDomainName'?: string;
    /**
     * 
     * @type {object}
     * @memberof HTTPKeywordCampaignParams
     */
    'metadata'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof HTTPKeywordCampaignParams
     */
    'personaIds'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof HTTPKeywordCampaignParams
     */
    'processingSpeedPerMinute'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof HTTPKeywordCampaignParams
     */
    'proxyIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HTTPKeywordCampaignParams
     */
    'proxyPoolId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HTTPKeywordCampaignParams
     */
    'proxySelectionStrategy'?: string;
    /**
     * 
     * @type {number}
     * @memberof HTTPKeywordCampaignParams
     */
    'retryAttempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof HTTPKeywordCampaignParams
     */
    'rotationIntervalSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof HTTPKeywordCampaignParams
     */
    'sourceCampaignId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HTTPKeywordCampaignParams
     */
    'sourceType'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof HTTPKeywordCampaignParams
     */
    'targetHttpPorts'?: Array<number>;
}
/**
 * HTTP keyword validation result information
 * @export
 * @interface HTTPKeywordResult
 */
export interface HTTPKeywordResult {
    /**
     * Number of validation attempts
     * @type {number}
     * @memberof HTTPKeywordResult
     */
    'attempts'?: number;
    /**
     * Content hash for deduplication
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'contentHash'?: string;
    /**
     * Record creation timestamp
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'createdAt'?: string;
    /**
     * Associated DNS result ID
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'dnsResultId'?: string;
    /**
     * Domain name validated
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'domainName'?: string;
    /**
     * Content snippet extracted
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'extractedContentSnippet'?: string;
    /**
     * Ad-hoc keywords found
     * @type {Array<string>}
     * @memberof HTTPKeywordResult
     */
    'foundAdHocKeywords'?: Array<string>;
    /**
     * Keywords found from keyword sets
     * @type {object}
     * @memberof HTTPKeywordResult
     */
    'foundKeywordsFromSets'?: object;
    /**
     * HTTP keyword campaign ID
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'httpKeywordCampaignId'?: string;
    /**
     * HTTP status code received
     * @type {number}
     * @memberof HTTPKeywordResult
     */
    'httpStatusCode'?: number;
    /**
     * Result unique identifier
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'id'?: string;
    /**
     * Last validation timestamp
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'lastCheckedAt'?: string;
    /**
     * Page title extracted
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'pageTitle'?: string;
    /**
     * HTTP response headers
     * @type {object}
     * @memberof HTTPKeywordResult
     */
    'responseHeaders'?: object;
    /**
     * Proxy used for validation
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'usedProxyId'?: string;
    /**
     * Persona used for validation
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'validatedByPersonaId'?: string;
    /**
     * Validation status
     * @type {string}
     * @memberof HTTPKeywordResult
     */
    'validationStatus'?: HTTPKeywordResultValidationStatusEnum;
}

export const HTTPKeywordResultValidationStatusEnum = {
    Pending: 'pending',
    Valid: 'valid',
    Invalid: 'invalid',
    Error: 'error',
    Skipped: 'skipped'
} as const;

export type HTTPKeywordResultValidationStatusEnum = typeof HTTPKeywordResultValidationStatusEnum[keyof typeof HTTPKeywordResultValidationStatusEnum];

/**
 * Response for HTTP keyword validation results
 * @export
 * @interface HTTPKeywordResultsResponse
 */
export interface HTTPKeywordResultsResponse {
    /**
     * 
     * @type {Array<HTTPKeywordResult>}
     * @memberof HTTPKeywordResultsResponse
     */
    'data'?: Array<HTTPKeywordResult>;
    /**
     * Next cursor for pagination
     * @type {string}
     * @memberof HTTPKeywordResultsResponse
     */
    'nextCursor'?: string;
    /**
     * Total number of HTTP keyword results
     * @type {number}
     * @memberof HTTPKeywordResultsResponse
     */
    'totalCount'?: number;
}
/**
 * Health status of the application and its components
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Build timestamp
     * @type {string}
     * @memberof HealthStatus
     */
    'buildTime': string;
    /**
     * Status of individual components
     * @type {{ [key: string]: ComponentStatus; }}
     * @memberof HealthStatus
     */
    'components': { [key: string]: ComponentStatus; };
    /**
     * Runtime environment
     * @type {string}
     * @memberof HealthStatus
     */
    'environment': string;
    /**
     * Overall health status
     * @type {string}
     * @memberof HealthStatus
     */
    'status': HealthStatusStatusEnum;
    /**
     * 
     * @type {SystemInfo}
     * @memberof HealthStatus
     */
    'systemInfo': SystemInfo;
    /**
     * Application version
     * @type {string}
     * @memberof HealthStatus
     */
    'version': string;
}

export const HealthStatusStatusEnum = {
    Ok: 'ok',
    Degraded: 'degraded',
    Error: 'error'
} as const;

export type HealthStatusStatusEnum = typeof HealthStatusStatusEnum[keyof typeof HealthStatusStatusEnum];

/**
 * Parameters for HTTP keyword validation campaigns
 * @export
 * @interface HttpKeywordParams
 */
export interface HttpKeywordParams {
    /**
     * Ad-hoc keywords for validation
     * @type {Array<string>}
     * @memberof HttpKeywordParams
     */
    'adHocKeywords'?: Array<string>;
    /**
     * Batch size for processing
     * @type {number}
     * @memberof HttpKeywordParams
     */
    'batchSize'?: number;
    /**
     * Keyword set IDs to use for validation
     * @type {Array<string>}
     * @memberof HttpKeywordParams
     */
    'keywordSetIds'?: Array<string>;
    /**
     * HTTP personas to use for validation
     * @type {Array<string>}
     * @memberof HttpKeywordParams
     */
    'personaIds': Array<string>;
    /**
     * Processing speed per minute
     * @type {number}
     * @memberof HttpKeywordParams
     */
    'processingSpeedPerMinute'?: number;
    /**
     * Proxy pool ID for requests
     * @type {string}
     * @memberof HttpKeywordParams
     */
    'proxyPoolId'?: string;
    /**
     * Strategy for proxy selection
     * @type {string}
     * @memberof HttpKeywordParams
     */
    'proxySelectionStrategy'?: string;
    /**
     * Number of retry attempts
     * @type {number}
     * @memberof HttpKeywordParams
     */
    'retryAttempts'?: number;
    /**
     * Persona rotation interval in seconds
     * @type {number}
     * @memberof HttpKeywordParams
     */
    'rotationIntervalSeconds'?: number;
    /**
     * Source DNS validation campaign ID
     * @type {string}
     * @memberof HttpKeywordParams
     */
    'sourceCampaignId': string;
    /**
     * Target HTTP ports for validation
     * @type {Array<number>}
     * @memberof HttpKeywordParams
     */
    'targetHttpPorts'?: Array<number>;
}
/**
 * HTTP persona configuration details
 * @export
 * @interface HttpPersonaConfig
 */
export interface HttpPersonaConfig {
    /**
     * Allow insecure TLS connections
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'allowInsecureTls'?: boolean;
    /**
     * Allowed HTTP status codes
     * @type {Array<number>}
     * @memberof HttpPersonaConfig
     */
    'allowedStatusCodes'?: Array<number>;
    /**
     * 
     * @type {CookieHandling}
     * @memberof HttpPersonaConfig
     */
    'cookieHandling'?: CookieHandling;
    /**
     * Capture DOM snapshots in headless browser
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'domSnapshot'?: boolean;
    /**
     * Fetch response body for keyword scanning
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'fetchBodyForKeywords'?: boolean;
    /**
     * Whether to follow HTTP redirects
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'followRedirects'?: boolean;
    /**
     * Order of HTTP headers
     * @type {Array<string>}
     * @memberof HttpPersonaConfig
     */
    'headerOrder'?: Array<string>;
    /**
     * Custom HTTP headers
     * @type {{ [key: string]: string; }}
     * @memberof HttpPersonaConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * Headless browser timeout in seconds
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'headlessTimeoutSeconds'?: number;
    /**
     * User agent for headless browser
     * @type {string}
     * @memberof HttpPersonaConfig
     */
    'headlessUserAgent'?: string;
    /**
     * 
     * @type {HTTP2SettingsConfig}
     * @memberof HttpPersonaConfig
     */
    'http2Settings'?: HTTP2SettingsConfig;
    /**
     * Skip TLS certificate verification
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'insecureSkipVerify'?: boolean;
    /**
     * Load images in headless browser
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'loadImages'?: boolean;
    /**
     * Maximum number of redirects to follow
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'maxRedirects'?: number;
    /**
     * Rate limit burst capacity
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'rateLimitBurst'?: number;
    /**
     * Rate limit in requests per second
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'rateLimitDps'?: number;
    /**
     * Request timeout in seconds
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'requestTimeoutSec'?: number;
    /**
     * Take screenshots in headless browser
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'screenshot'?: boolean;
    /**
     * Enable JavaScript execution in headless browser
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'scriptExecution'?: boolean;
    /**
     * 
     * @type {TLSClientHello}
     * @memberof HttpPersonaConfig
     */
    'tlsClientHello'?: TLSClientHello;
    /**
     * Use headless browser for requests
     * @type {boolean}
     * @memberof HttpPersonaConfig
     */
    'useHeadless'?: boolean;
    /**
     * User agent string for HTTP requests
     * @type {string}
     * @memberof HttpPersonaConfig
     */
    'userAgent': string;
    /**
     * Viewport height for headless browser
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'viewportHeight'?: number;
    /**
     * Viewport width for headless browser
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'viewportWidth'?: number;
    /**
     * Wait delay before capturing content
     * @type {number}
     * @memberof HttpPersonaConfig
     */
    'waitDelaySeconds'?: number;
}
/**
 * Result of keyword extraction for a single URL
 * @export
 * @interface KeywordExtractionAPIResult
 */
export interface KeywordExtractionAPIResult {
    /**
     * UUID of DNS persona actually used
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'dnsPersonaIdUsed'?: string;
    /**
     * Error message if extraction failed
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'error'?: string;
    /**
     * Final URL after redirects
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'finalUrl'?: string;
    /**
     * UUID of HTTP persona actually used
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'httpPersonaIdUsed'?: string;
    /**
     * UUID of keyword set used
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'keywordSetIdUsed': string;
    /**
     * Array of keyword extraction results
     * @type {Array<KeywordExtractionResult>}
     * @memberof KeywordExtractionAPIResult
     */
    'matches'?: Array<KeywordExtractionResult>;
    /**
     * UUID of proxy actually used
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'proxyIdUsed'?: string;
    /**
     * HTTP status code from the request
     * @type {number}
     * @memberof KeywordExtractionAPIResult
     */
    'statusCode'?: number;
    /**
     * Original URL requested
     * @type {string}
     * @memberof KeywordExtractionAPIResult
     */
    'url': string;
}
/**
 * Single item in a batch keyword extraction request
 * @export
 * @interface KeywordExtractionRequestItem
 */
export interface KeywordExtractionRequestItem {
    /**
     * Optional UUID of DNS persona to use
     * @type {string}
     * @memberof KeywordExtractionRequestItem
     */
    'dnsPersonaId'?: string;
    /**
     * Optional UUID of HTTP persona to use
     * @type {string}
     * @memberof KeywordExtractionRequestItem
     */
    'httpPersonaId'?: string;
    /**
     * UUID of the keyword set to use for extraction
     * @type {string}
     * @memberof KeywordExtractionRequestItem
     */
    'keywordSetId': string;
    /**
     * URL to extract keywords from
     * @type {string}
     * @memberof KeywordExtractionRequestItem
     */
    'url': string;
}
/**
 * Single keyword extraction match result
 * @export
 * @interface KeywordExtractionResult
 */
export interface KeywordExtractionResult {
    /**
     * Number of matches found
     * @type {number}
     * @memberof KeywordExtractionResult
     */
    'count': number;
    /**
     * The matched keyword or pattern
     * @type {string}
     * @memberof KeywordExtractionResult
     */
    'keyword': string;
    /**
     * Array of text matches for this keyword
     * @type {Array<string>}
     * @memberof KeywordExtractionResult
     */
    'matches': Array<string>;
}
/**
 * 
 * @export
 * @interface KeywordRule
 */
export interface KeywordRule {
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'category'?: string;
    /**
     * 
     * @type {number}
     * @memberof KeywordRule
     */
    'contextChars'?: number;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordRule
     */
    'isCaseSensitive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'keywordSetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'pattern'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'ruleType'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRule
     */
    'updatedAt'?: string;
}
/**
 * Request to create or update a keyword rule
 * @export
 * @interface KeywordRuleRequest
 */
export interface KeywordRuleRequest {
    /**
     * Category for organizing related rules
     * @type {string}
     * @memberof KeywordRuleRequest
     */
    'category'?: string;
    /**
     * Number of context characters to include around matches
     * @type {number}
     * @memberof KeywordRuleRequest
     */
    'contextChars'?: number;
    /**
     * Whether pattern matching is case sensitive
     * @type {boolean}
     * @memberof KeywordRuleRequest
     */
    'isCaseSensitive'?: boolean;
    /**
     * Pattern to match against content
     * @type {string}
     * @memberof KeywordRuleRequest
     */
    'pattern': string;
    /**
     * Type of rule pattern matching
     * @type {string}
     * @memberof KeywordRuleRequest
     */
    'ruleType': KeywordRuleRequestRuleTypeEnum;
}

export const KeywordRuleRequestRuleTypeEnum = {
    String: 'string',
    Regex: 'regex'
} as const;

export type KeywordRuleRequestRuleTypeEnum = typeof KeywordRuleRequestRuleTypeEnum[keyof typeof KeywordRuleRequestRuleTypeEnum];

/**
 * 
 * @export
 * @interface KeywordSet
 */
export interface KeywordSet {
    /**
     * 
     * @type {string}
     * @memberof KeywordSet
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordSet
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordSet
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KeywordSet
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KeywordSet
     */
    'name'?: string;
    /**
     * 
     * @type {Array<KeywordRule>}
     * @memberof KeywordSet
     */
    'rules'?: Array<KeywordRule>;
    /**
     * 
     * @type {string}
     * @memberof KeywordSet
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface LeadItem
 */
export interface LeadItem {
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'previousCampaignId'?: string;
    /**
     * 
     * @type {number}
     * @memberof LeadItem
     */
    'similarityScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof LeadItem
     */
    'sourceUrl'?: string;
}
/**
 * Logging configuration
 * @export
 * @interface LoggingConfig
 */
export interface LoggingConfig {
    /**
     * Enable file-based logging
     * @type {boolean}
     * @memberof LoggingConfig
     */
    'enableFileLogging'?: boolean;
    /**
     * Enable JSON log format
     * @type {boolean}
     * @memberof LoggingConfig
     */
    'enableJSONFormat'?: boolean;
    /**
     * Enable performance logging
     * @type {boolean}
     * @memberof LoggingConfig
     */
    'enablePerformanceLogging'?: boolean;
    /**
     * Enable request logging
     * @type {boolean}
     * @memberof LoggingConfig
     */
    'enableRequestLogging'?: boolean;
    /**
     * Log level
     * @type {string}
     * @memberof LoggingConfig
     */
    'level'?: LoggingConfigLevelEnum;
    /**
     * Directory for log files
     * @type {string}
     * @memberof LoggingConfig
     */
    'logDirectory'?: string;
    /**
     * Maximum age of log files in days
     * @type {number}
     * @memberof LoggingConfig
     */
    'maxAge'?: number;
    /**
     * Maximum number of backup log files
     * @type {number}
     * @memberof LoggingConfig
     */
    'maxBackups'?: number;
    /**
     * Maximum log file size in MB
     * @type {number}
     * @memberof LoggingConfig
     */
    'maxFileSize'?: number;
}

export const LoggingConfigLevelEnum = {
    Debug: 'DEBUG',
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type LoggingConfigLevelEnum = typeof LoggingConfigLevelEnum[keyof typeof LoggingConfigLevelEnum];

/**
 * Login credentials
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * CAPTCHA token for bot protection
     * @type {string}
     * @memberof LoginRequest
     */
    'captchaToken'?: string;
    /**
     * User email address
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * User password (minimum 6 characters)
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
    /**
     * Whether to remember the user session
     * @type {boolean}
     * @memberof LoginRequest
     */
    'rememberMe'?: boolean;
}
/**
 * Login response
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * Session expiration time
     * @type {string}
     * @memberof LoginResponse
     */
    'expiresAt'?: string;
    /**
     * Session identifier
     * @type {string}
     * @memberof LoginResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {User}
     * @memberof LoginResponse
     */
    'user'?: User;
}
/**
 * Page information for pagination
 * @export
 * @interface PageInfo
 */
export interface PageInfo {
    /**
     * Total number of items
     * @type {number}
     * @memberof PageInfo
     */
    'count'?: number;
    /**
     * Current page number
     * @type {number}
     * @memberof PageInfo
     */
    'current'?: number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof PageInfo
     */
    'pageSize'?: number;
    /**
     * Total number of pages
     * @type {number}
     * @memberof PageInfo
     */
    'total'?: number;
}
/**
 * Pagination metadata
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * 
     * @type {PageInfo}
     * @memberof PaginationMetadata
     */
    'page'?: PageInfo;
}
/**
 * Request to get the current offset for a domain generation pattern
 * @export
 * @interface PatternOffsetRequest
 */
export interface PatternOffsetRequest {
    /**
     * Character set for domain generation (e.g., \'abc\', \'123\')
     * @type {string}
     * @memberof PatternOffsetRequest
     */
    'characterSet': string;
    /**
     * Constant string part of the domain
     * @type {string}
     * @memberof PatternOffsetRequest
     */
    'constantString': string;
    /**
     * Type of pattern (prefix, suffix, or both)
     * @type {string}
     * @memberof PatternOffsetRequest
     */
    'patternType': PatternOffsetRequestPatternTypeEnum;
    /**
     * Top-level domain (e.g., \'.com\', \'.net\')
     * @type {string}
     * @memberof PatternOffsetRequest
     */
    'tld': string;
    /**
     * Length of the variable part
     * @type {number}
     * @memberof PatternOffsetRequest
     */
    'variableLength': number;
}

export const PatternOffsetRequestPatternTypeEnum = {
    Prefix: 'prefix',
    Suffix: 'suffix',
    Both: 'both'
} as const;

export type PatternOffsetRequestPatternTypeEnum = typeof PatternOffsetRequestPatternTypeEnum[keyof typeof PatternOffsetRequestPatternTypeEnum];

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {object}
     * @memberof Persona
     */
    'configDetails'?: object;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Persona
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastTested'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'personaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'status'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string;
}
/**
 * Response for persona list
 * @export
 * @interface PersonaListResponse
 */
export interface PersonaListResponse {
    /**
     * 
     * @type {Array<Persona>}
     * @memberof PersonaListResponse
     */
    'data'?: Array<Persona>;
    /**
     * Response message
     * @type {string}
     * @memberof PersonaListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaListResponse
     */
    'status'?: PersonaListResponseStatusEnum;
}

export const PersonaListResponseStatusEnum = {
    Success: 'success'
} as const;

export type PersonaListResponseStatusEnum = typeof PersonaListResponseStatusEnum[keyof typeof PersonaListResponseStatusEnum];

/**
 * Result of persona test operation
 * @export
 * @interface PersonaTestResult
 */
export interface PersonaTestResult {
    /**
     * 
     * @type {PersonaTestResultData}
     * @memberof PersonaTestResult
     */
    'data'?: PersonaTestResultData;
    /**
     * Response message
     * @type {string}
     * @memberof PersonaTestResult
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaTestResult
     */
    'status'?: PersonaTestResultStatusEnum;
}

export const PersonaTestResultStatusEnum = {
    Success: 'success'
} as const;

export type PersonaTestResultStatusEnum = typeof PersonaTestResultStatusEnum[keyof typeof PersonaTestResultStatusEnum];

/**
 * 
 * @export
 * @interface PersonaTestResultData
 */
export interface PersonaTestResultData {
    /**
     * Test result message
     * @type {string}
     * @memberof PersonaTestResultData
     */
    'message'?: string;
    /**
     * Persona ID that was tested
     * @type {string}
     * @memberof PersonaTestResultData
     */
    'personaId'?: string;
    /**
     * Type of persona tested
     * @type {string}
     * @memberof PersonaTestResultData
     */
    'personaType'?: PersonaTestResultDataPersonaTypeEnum;
    /**
     * Test result status
     * @type {string}
     * @memberof PersonaTestResultData
     */
    'status'?: string;
    /**
     * Test execution timestamp
     * @type {string}
     * @memberof PersonaTestResultData
     */
    'testedAt'?: string;
}

export const PersonaTestResultDataPersonaTypeEnum = {
    Dns: 'dns',
    Http: 'http'
} as const;

export type PersonaTestResultDataPersonaTypeEnum = typeof PersonaTestResultDataPersonaTypeEnum[keyof typeof PersonaTestResultDataPersonaTypeEnum];

/**
 * 
 * @export
 * @interface Ping200Response
 */
export interface Ping200Response {
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ping200Response
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface Proxy
 */
export interface Proxy {
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proxy
     */
    'failureCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'inputPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'inputUsername'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Proxy
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Proxy
     */
    'isHealthy'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'lastCheckedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'lastStatus'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'lastTested'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proxy
     */
    'latencyMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'notes'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proxy
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof Proxy
     */
    'successCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proxy
     */
    'username'?: string;
}
/**
 * Proxy manager configuration
 * @export
 * @interface ProxyManagerConfig
 */
export interface ProxyManagerConfig {
    /**
     * Initial health check timeout in seconds
     * @type {number}
     * @memberof ProxyManagerConfig
     */
    'initialHealthCheckTimeoutSeconds'?: number;
    /**
     * Maximum concurrent initial health checks
     * @type {number}
     * @memberof ProxyManagerConfig
     */
    'maxConcurrentInitialChecks'?: number;
    /**
     * Proxy test timeout in seconds
     * @type {number}
     * @memberof ProxyManagerConfig
     */
    'testTimeoutSeconds': number;
    /**
     * URL to use for proxy testing
     * @type {string}
     * @memberof ProxyManagerConfig
     */
    'testUrl'?: string;
}
/**
 * 
 * @export
 * @interface ProxyPool
 */
export interface ProxyPool {
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyPool
     */
    'healthCheckEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProxyPool
     */
    'healthCheckIntervalSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyPool
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProxyPool
     */
    'maxRetries'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'poolStrategy'?: string;
    /**
     * 
     * @type {Array<Proxy>}
     * @memberof ProxyPool
     */
    'proxies'?: Array<Proxy>;
    /**
     * 
     * @type {number}
     * @memberof ProxyPool
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProxyPool
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ProxyPoolMembership
 */
export interface ProxyPoolMembership {
    /**
     * 
     * @type {string}
     * @memberof ProxyPoolMembership
     */
    'addedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyPoolMembership
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProxyPoolMembership
     */
    'poolId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProxyPoolMembership
     */
    'proxyId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProxyPoolMembership
     */
    'weight'?: number;
}
/**
 * Request to create or update a proxy pool
 * @export
 * @interface ProxyPoolRequest
 */
export interface ProxyPoolRequest {
    /**
     * Proxy pool description
     * @type {string}
     * @memberof ProxyPoolRequest
     */
    'description'?: string;
    /**
     * Whether health checks are enabled for the pool
     * @type {boolean}
     * @memberof ProxyPoolRequest
     */
    'healthCheckEnabled'?: boolean;
    /**
     * Health check interval in seconds
     * @type {number}
     * @memberof ProxyPoolRequest
     */
    'healthCheckIntervalSeconds'?: number;
    /**
     * Whether the proxy pool is enabled
     * @type {boolean}
     * @memberof ProxyPoolRequest
     */
    'isEnabled'?: boolean;
    /**
     * Maximum retry attempts for proxy requests
     * @type {number}
     * @memberof ProxyPoolRequest
     */
    'maxRetries'?: number;
    /**
     * Proxy pool name
     * @type {string}
     * @memberof ProxyPoolRequest
     */
    'name': string;
    /**
     * Pool selection strategy (e.g., round_robin, random, weighted)
     * @type {string}
     * @memberof ProxyPoolRequest
     */
    'poolStrategy'?: string;
    /**
     * Timeout for proxy requests in seconds
     * @type {number}
     * @memberof ProxyPoolRequest
     */
    'timeoutSeconds'?: number;
}
/**
 * Proxy status information
 * @export
 * @interface ProxyStatus
 */
export interface ProxyStatus {
    /**
     * Proxy address
     * @type {string}
     * @memberof ProxyStatus
     */
    'address'?: string;
    /**
     * Number of consecutive failures
     * @type {number}
     * @memberof ProxyStatus
     */
    'consecutiveFailures'?: number;
    /**
     * Proxy description
     * @type {string}
     * @memberof ProxyStatus
     */
    'description'?: string;
    /**
     * Proxy ID
     * @type {string}
     * @memberof ProxyStatus
     */
    'id'?: string;
    /**
     * Whether the proxy is healthy
     * @type {boolean}
     * @memberof ProxyStatus
     */
    'isHealthy'?: boolean;
    /**
     * Last failure timestamp
     * @type {string}
     * @memberof ProxyStatus
     */
    'lastFailure'?: string;
    /**
     * Proxy name
     * @type {string}
     * @memberof ProxyStatus
     */
    'name'?: string;
    /**
     * Proxy password (may be masked)
     * @type {string}
     * @memberof ProxyStatus
     */
    'password'?: string;
    /**
     * Proxy protocol
     * @type {string}
     * @memberof ProxyStatus
     */
    'protocol'?: string;
    /**
     * Whether the proxy is enabled by user
     * @type {boolean}
     * @memberof ProxyStatus
     */
    'userEnabled'?: boolean;
    /**
     * Proxy username
     * @type {string}
     * @memberof ProxyStatus
     */
    'username'?: string;
}
/**
 * Result of proxy test operation
 * @export
 * @interface ProxyTestResult
 */
export interface ProxyTestResult {
    /**
     * Test duration in milliseconds
     * @type {number}
     * @memberof ProxyTestResult
     */
    'durationMs'?: number;
    /**
     * Error message if test failed
     * @type {string}
     * @memberof ProxyTestResult
     */
    'error'?: string;
    /**
     * Proxy ID that was tested
     * @type {string}
     * @memberof ProxyTestResult
     */
    'proxyId'?: string;
    /**
     * IP address returned by the proxy test
     * @type {string}
     * @memberof ProxyTestResult
     */
    'returnedIp'?: string;
    /**
     * HTTP status code from test request
     * @type {number}
     * @memberof ProxyTestResult
     */
    'statusCode'?: number;
    /**
     * Whether the test was successful
     * @type {boolean}
     * @memberof ProxyTestResult
     */
    'success'?: boolean;
}
/**
 * Rate limiter configuration
 * @export
 * @interface RateLimiterConfig
 */
export interface RateLimiterConfig {
    /**
     * Maximum requests per window
     * @type {number}
     * @memberof RateLimiterConfig
     */
    'maxRequests': number;
    /**
     * Rate limit window in seconds
     * @type {number}
     * @memberof RateLimiterConfig
     */
    'windowSeconds': number;
}
/**
 * Session refresh response
 * @export
 * @interface RefreshResponse
 */
export interface RefreshResponse {
    /**
     * New session expiration time
     * @type {string}
     * @memberof RefreshResponse
     */
    'expiresAt'?: string;
    /**
     * New session identifier
     * @type {string}
     * @memberof RefreshResponse
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface RemoveProxyFromPool200Response
 */
export interface RemoveProxyFromPool200Response {
    /**
     * Removal status
     * @type {boolean}
     * @memberof RemoveProxyFromPool200Response
     */
    'removed'?: boolean;
}
/**
 * Server configuration
 * @export
 * @interface ServerConfig
 */
export interface ServerConfig {
    /**
     * Gin framework mode
     * @type {string}
     * @memberof ServerConfig
     */
    'ginMode'?: ServerConfigGinModeEnum;
    /**
     * Server port
     * @type {string}
     * @memberof ServerConfig
     */
    'port'?: string;
    /**
     * Stream chunk size in bytes
     * @type {number}
     * @memberof ServerConfig
     */
    'streamChunkSize'?: number;
}

export const ServerConfigGinModeEnum = {
    Debug: 'debug',
    Release: 'release',
    Test: 'test'
} as const;

export type ServerConfigGinModeEnum = typeof ServerConfigGinModeEnum[keyof typeof ServerConfigGinModeEnum];

/**
 * Simple status response
 * @export
 * @interface SimpleStatus
 */
export interface SimpleStatus {
    /**
     * Status message
     * @type {string}
     * @memberof SimpleStatus
     */
    'status': string;
}
/**
 * Standard API response wrapper
 * @export
 * @interface StandardAPIResponse
 */
export interface StandardAPIResponse {
    /**
     * Response data (only present on success)
     * @type {any}
     * @memberof StandardAPIResponse
     */
    'data'?: any;
    /**
     * Error details (only present on error)
     * @type {string}
     * @memberof StandardAPIResponse
     */
    'error'?: string;
    /**
     * Human-readable message
     * @type {string}
     * @memberof StandardAPIResponse
     */
    'message': string;
    /**
     * Status of the response
     * @type {string}
     * @memberof StandardAPIResponse
     */
    'status': StandardAPIResponseStatusEnum;
}

export const StandardAPIResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type StandardAPIResponseStatusEnum = typeof StandardAPIResponseStatusEnum[keyof typeof StandardAPIResponseStatusEnum];

/**
 * System information and resources
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * Go runtime version
     * @type {string}
     * @memberof SystemInfo
     */
    'goVersion': string;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof SystemInfo
     */
    'numCPU': number;
    /**
     * Number of active goroutines
     * @type {number}
     * @memberof SystemInfo
     */
    'numGoroutine': number;
}
/**
 * TLS ClientHello configuration
 * @export
 * @interface TLSClientHello
 */
export interface TLSClientHello {
    /**
     * Supported cipher suites
     * @type {Array<string>}
     * @memberof TLSClientHello
     */
    'cipherSuites'?: Array<string>;
    /**
     * Supported curve preferences
     * @type {Array<string>}
     * @memberof TLSClientHello
     */
    'curvePreferences'?: Array<string>;
    /**
     * JA3 fingerprint
     * @type {string}
     * @memberof TLSClientHello
     */
    'ja3'?: string;
    /**
     * Maximum TLS version
     * @type {string}
     * @memberof TLSClientHello
     */
    'maxVersion'?: TLSClientHelloMaxVersionEnum;
    /**
     * Minimum TLS version
     * @type {string}
     * @memberof TLSClientHello
     */
    'minVersion'?: TLSClientHelloMinVersionEnum;
}

export const TLSClientHelloMaxVersionEnum = {
    Tls10: 'TLS10',
    Tls11: 'TLS11',
    Tls12: 'TLS12',
    Tls13: 'TLS13'
} as const;

export type TLSClientHelloMaxVersionEnum = typeof TLSClientHelloMaxVersionEnum[keyof typeof TLSClientHelloMaxVersionEnum];
export const TLSClientHelloMinVersionEnum = {
    Tls10: 'TLS10',
    Tls11: 'TLS11',
    Tls12: 'TLS12',
    Tls13: 'TLS13'
} as const;

export type TLSClientHelloMinVersionEnum = typeof TLSClientHelloMinVersionEnum[keyof typeof TLSClientHelloMinVersionEnum];

/**
 * Request to update an existing keyword set
 * @export
 * @interface UpdateKeywordSetRequest
 */
export interface UpdateKeywordSetRequest {
    /**
     * Keyword set description
     * @type {string}
     * @memberof UpdateKeywordSetRequest
     */
    'description'?: string;
    /**
     * Whether the keyword set is enabled
     * @type {boolean}
     * @memberof UpdateKeywordSetRequest
     */
    'isEnabled'?: boolean;
    /**
     * Keyword set name
     * @type {string}
     * @memberof UpdateKeywordSetRequest
     */
    'name'?: string;
    /**
     * List of keyword rules (replaces all existing rules)
     * @type {Array<KeywordRuleRequest>}
     * @memberof UpdateKeywordSetRequest
     */
    'rules'?: Array<KeywordRuleRequest>;
}
/**
 * Request to update an existing persona
 * @export
 * @interface UpdatePersonaRequest
 */
export interface UpdatePersonaRequest {
    /**
     * 
     * @type {CreatePersonaRequestConfigDetails}
     * @memberof UpdatePersonaRequest
     */
    'configDetails'?: CreatePersonaRequestConfigDetails;
    /**
     * Persona description
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'description'?: string;
    /**
     * Whether the persona is enabled
     * @type {boolean}
     * @memberof UpdatePersonaRequest
     */
    'isEnabled'?: boolean;
    /**
     * Persona name
     * @type {string}
     * @memberof UpdatePersonaRequest
     */
    'name'?: string;
}
/**
 * Request to update an existing proxy
 * @export
 * @interface UpdateProxyRequest
 */
export interface UpdateProxyRequest {
    /**
     * Proxy address (host:port)
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'address'?: string;
    /**
     * Country code for the proxy location
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'countryCode'?: string;
    /**
     * Proxy description
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'description'?: string;
    /**
     * Whether the proxy is enabled
     * @type {boolean}
     * @memberof UpdateProxyRequest
     */
    'isEnabled'?: boolean;
    /**
     * Proxy name
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'name'?: string;
    /**
     * Proxy password for authentication
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'password'?: string;
    /**
     * Proxy protocol
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'protocol'?: UpdateProxyRequestProtocolEnum;
    /**
     * Proxy username for authentication
     * @type {string}
     * @memberof UpdateProxyRequest
     */
    'username'?: string;
}

export const UpdateProxyRequestProtocolEnum = {
    Http: 'http',
    Https: 'https',
    Socks5: 'socks5',
    Socks4: 'socks4'
} as const;

export type UpdateProxyRequestProtocolEnum = typeof UpdateProxyRequestProtocolEnum[keyof typeof UpdateProxyRequestProtocolEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'emailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLoginAt'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof User
     */
    'lastLoginIp'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'mfaEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'mfaLastUsedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'mustChangePassword'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
}
/**
 * Worker configuration
 * @export
 * @interface WorkerConfig
 */
export interface WorkerConfig {
    /**
     * Batch size for processing
     * @type {number}
     * @memberof WorkerConfig
     */
    'batchSize'?: number;
    /**
     * DNS subtask concurrency
     * @type {number}
     * @memberof WorkerConfig
     */
    'dnsSubtaskConcurrency'?: number;
    /**
     * Error retry delay in seconds
     * @type {number}
     * @memberof WorkerConfig
     */
    'errorRetryDelaySeconds'?: number;
    /**
     * HTTP keyword subtask concurrency
     * @type {number}
     * @memberof WorkerConfig
     */
    'httpKeywordSubtaskConcurrency'?: number;
    /**
     * Job processing timeout in minutes
     * @type {number}
     * @memberof WorkerConfig
     */
    'jobProcessingTimeoutMinutes'?: number;
    /**
     * Maximum job retry attempts
     * @type {number}
     * @memberof WorkerConfig
     */
    'maxJobRetries'?: number;
    /**
     * Maximum retry attempts
     * @type {number}
     * @memberof WorkerConfig
     */
    'maxRetries'?: number;
    /**
     * Number of worker goroutines
     * @type {number}
     * @memberof WorkerConfig
     */
    'numWorkers'?: number;
    /**
     * Polling interval in seconds
     * @type {number}
     * @memberof WorkerConfig
     */
    'pollIntervalSeconds'?: number;
    /**
     * Retry delay in seconds
     * @type {number}
     * @memberof WorkerConfig
     */
    'retryDelaySeconds'?: number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the password for the currently authenticated user
         * @summary Change password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticates a user and creates a session
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the current session and clears session cookie
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes the current session
         * @summary Refresh session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the password for the currently authenticated user
         * @summary Change password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticates a user and creates a session
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the current session and clears session cookie
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refreshes the current session
         * @summary Refresh session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Changes the password for the currently authenticated user
         * @summary Change password
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<StandardAPIResponse> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticates a user and creates a session
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the current session and clears session cookie
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<StandardAPIResponse> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes the current session
         * @summary Refresh session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSession(options?: RawAxiosRequestConfig): AxiosPromise<RefreshResponse> {
            return localVarFp.refreshSession(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Changes the password for the currently authenticated user
     * @summary Change password
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticates a user and creates a session
     * @summary User login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the current session and clears session cookie
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refreshes the current session
     * @summary Refresh session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshSession(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshSession(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permanently deletes multiple campaigns and all their associated data
         * @summary Bulk delete campaigns
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteCampaigns: async (bulkDeleteRequest: BulkDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDeleteRequest' is not null or undefined
            assertParamExists('bulkDeleteCampaigns', 'bulkDeleteRequest', bulkDeleteRequest)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a campaign, setting it to cancelled status
         * @summary Cancel campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('cancelCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/cancel`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new campaign using unified endpoint supporting all campaign types
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (createCampaignRequest: CreateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            assertParamExists('createCampaign', 'createCampaignRequest', createCampaignRequest)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a campaign and all its associated data
         * @summary Delete campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('deleteCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information about a campaign including type-specific parameters
         * @summary Get campaign details
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignDetails: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('getCampaignDetails', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets DNS validation results for a DNS validation campaign
         * @summary Get DNS validation results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSValidationResults: async (campaignId: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('getDNSValidationResults', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/results/dns-validation`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the current offset for a domain generation pattern to prevent duplicate domains across campaigns
         * @summary Get domain generation pattern offset
         * @param {PatternOffsetRequest} patternOffsetRequest Pattern configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainGenerationPatternOffset: async (patternOffsetRequest: PatternOffsetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patternOffsetRequest' is not null or undefined
            assertParamExists('getDomainGenerationPatternOffset', 'patternOffsetRequest', patternOffsetRequest)
            const localVarPath = `/campaigns/domain-generation/pattern-offset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patternOffsetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets generated domains for a domain generation campaign
         * @summary Get generated domains
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of domains to return
         * @param {number} [cursor] Cursor for pagination (offset index)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneratedDomains: async (campaignId: string, limit?: number, cursor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('getGeneratedDomains', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/results/generated-domains`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets HTTP keyword validation results for an HTTP keyword validation campaign
         * @summary Get HTTP keyword results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTTPKeywordResults: async (campaignId: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('getHTTPKeywordResults', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/results/http-keyword`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all campaigns with pagination and filtering support
         * @summary List campaigns
         * @param {number} [limit] Maximum number of campaigns to return (1-100)
         * @param {number} [offset] Number of campaigns to skip for pagination
         * @param {ListCampaignsStatusEnum} [status] Filter campaigns by status
         * @param {ListCampaignsTypeEnum} [type] Filter campaigns by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns: async (limit?: number, offset?: number, status?: ListCampaignsStatusEnum, type?: ListCampaignsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pauses a running or queued campaign
         * @summary Pause campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('pauseCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/pause`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a paused campaign by queuing it for execution
         * @summary Resume campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('resumeCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/resume`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a campaign by transitioning it from pending to queued status
         * @summary Start campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('startCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/start`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers domain-centric DNS validation for all domains in a completed domain generation campaign
         * @summary Validate DNS for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDNSForCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('validateDNSForCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/validate-dns`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers domain-centric HTTP keyword validation for all domains in a completed DNS validation campaign
         * @summary Validate HTTP for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateHTTPForCampaign: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('validateHTTPForCampaign', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/validate-http`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * Permanently deletes multiple campaigns and all their associated data
         * @summary Bulk delete campaigns
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteCampaigns(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteCampaigns(bulkDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.bulkDeleteCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels a campaign, setting it to cancelled status
         * @summary Cancel campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.cancelCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new campaign using unified endpoint supporting all campaign types
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(createCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.createCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently deletes a campaign and all its associated data
         * @summary Delete campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.deleteCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed information about a campaign including type-specific parameters
         * @summary Get campaign details
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignDetails(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignDetails(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getCampaignDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets DNS validation results for a DNS validation campaign
         * @summary Get DNS validation results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNSValidationResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSValidationResultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNSValidationResults(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getDNSValidationResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the current offset for a domain generation pattern to prevent duplicate domains across campaigns
         * @summary Get domain generation pattern offset
         * @param {PatternOffsetRequest} patternOffsetRequest Pattern configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainGenerationPatternOffset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainGenerationPatternOffset(patternOffsetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getDomainGenerationPatternOffset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets generated domains for a domain generation campaign
         * @summary Get generated domains
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of domains to return
         * @param {number} [cursor] Cursor for pagination (offset index)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneratedDomains(campaignId: string, limit?: number, cursor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneratedDomainsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeneratedDomains(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getGeneratedDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets HTTP keyword validation results for an HTTP keyword validation campaign
         * @summary Get HTTP keyword results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHTTPKeywordResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPKeywordResultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHTTPKeywordResults(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getHTTPKeywordResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all campaigns with pagination and filtering support
         * @summary List campaigns
         * @param {number} [limit] Maximum number of campaigns to return (1-100)
         * @param {number} [offset] Number of campaigns to skip for pagination
         * @param {ListCampaignsStatusEnum} [status] Filter campaigns by status
         * @param {ListCampaignsTypeEnum} [type] Filter campaigns by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCampaigns(limit?: number, offset?: number, status?: ListCampaignsStatusEnum, type?: ListCampaignsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCampaigns(limit, offset, status, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.listCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pauses a running or queued campaign
         * @summary Pause campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.pauseCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a paused campaign by queuing it for execution
         * @summary Resume campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.resumeCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts a campaign by transitioning it from pending to queued status
         * @summary Start campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.startCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers domain-centric DNS validation for all domains in a completed domain generation campaign
         * @summary Validate DNS for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateDNSForCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateDNSForCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.validateDNSForCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers domain-centric HTTP keyword validation for all domains in a completed DNS validation campaign
         * @summary Validate HTTP for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateHTTPForCampaign(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateHTTPForCampaign(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.validateHTTPForCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * Permanently deletes multiple campaigns and all their associated data
         * @summary Bulk delete campaigns
         * @param {BulkDeleteRequest} bulkDeleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteCampaigns(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkDeleteResponse> {
            return localVarFp.bulkDeleteCampaigns(bulkDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a campaign, setting it to cancelled status
         * @summary Cancel campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.cancelCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new campaign using unified endpoint supporting all campaign types
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.createCampaign(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a campaign and all its associated data
         * @summary Delete campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.deleteCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed information about a campaign including type-specific parameters
         * @summary Get campaign details
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignDetails(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignDetailsResponse> {
            return localVarFp.getCampaignDetails(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets DNS validation results for a DNS validation campaign
         * @summary Get DNS validation results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSValidationResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<DNSValidationResultsResponse> {
            return localVarFp.getDNSValidationResults(campaignId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the current offset for a domain generation pattern to prevent duplicate domains across campaigns
         * @summary Get domain generation pattern offset
         * @param {PatternOffsetRequest} patternOffsetRequest Pattern configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetDomainGenerationPatternOffset200Response> {
            return localVarFp.getDomainGenerationPatternOffset(patternOffsetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets generated domains for a domain generation campaign
         * @summary Get generated domains
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of domains to return
         * @param {number} [cursor] Cursor for pagination (offset index)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneratedDomains(campaignId: string, limit?: number, cursor?: number, options?: RawAxiosRequestConfig): AxiosPromise<GeneratedDomainsResponse> {
            return localVarFp.getGeneratedDomains(campaignId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets HTTP keyword validation results for an HTTP keyword validation campaign
         * @summary Get HTTP keyword results
         * @param {string} campaignId Campaign UUID
         * @param {number} [limit] Maximum number of results to return
         * @param {string} [cursor] Cursor for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTTPKeywordResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<HTTPKeywordResultsResponse> {
            return localVarFp.getHTTPKeywordResults(campaignId, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all campaigns with pagination and filtering support
         * @summary List campaigns
         * @param {number} [limit] Maximum number of campaigns to return (1-100)
         * @param {number} [offset] Number of campaigns to skip for pagination
         * @param {ListCampaignsStatusEnum} [status] Filter campaigns by status
         * @param {ListCampaignsTypeEnum} [type] Filter campaigns by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCampaigns(limit?: number, offset?: number, status?: ListCampaignsStatusEnum, type?: ListCampaignsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<CampaignListResponse> {
            return localVarFp.listCampaigns(limit, offset, status, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Pauses a running or queued campaign
         * @summary Pause campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.pauseCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused campaign by queuing it for execution
         * @summary Resume campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.resumeCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a campaign by transitioning it from pending to queued status
         * @summary Start campaign
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.startCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers domain-centric DNS validation for all domains in a completed domain generation campaign
         * @summary Validate DNS for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateDNSForCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.validateDNSForCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers domain-centric HTTP keyword validation for all domains in a completed DNS validation campaign
         * @summary Validate HTTP for campaign domains
         * @param {string} campaignId Campaign UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateHTTPForCampaign(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignOperationResponse> {
            return localVarFp.validateHTTPForCampaign(campaignId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * Permanently deletes multiple campaigns and all their associated data
     * @summary Bulk delete campaigns
     * @param {BulkDeleteRequest} bulkDeleteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public bulkDeleteCampaigns(bulkDeleteRequest: BulkDeleteRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).bulkDeleteCampaigns(bulkDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a campaign, setting it to cancelled status
     * @summary Cancel campaign
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public cancelCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).cancelCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new campaign using unified endpoint supporting all campaign types
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).createCampaign(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a campaign and all its associated data
     * @summary Delete campaign
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public deleteCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).deleteCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed information about a campaign including type-specific parameters
     * @summary Get campaign details
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getCampaignDetails(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getCampaignDetails(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets DNS validation results for a DNS validation campaign
     * @summary Get DNS validation results
     * @param {string} campaignId Campaign UUID
     * @param {number} [limit] Maximum number of results to return
     * @param {string} [cursor] Cursor for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getDNSValidationResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getDNSValidationResults(campaignId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the current offset for a domain generation pattern to prevent duplicate domains across campaigns
     * @summary Get domain generation pattern offset
     * @param {PatternOffsetRequest} patternOffsetRequest Pattern configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getDomainGenerationPatternOffset(patternOffsetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets generated domains for a domain generation campaign
     * @summary Get generated domains
     * @param {string} campaignId Campaign UUID
     * @param {number} [limit] Maximum number of domains to return
     * @param {number} [cursor] Cursor for pagination (offset index)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getGeneratedDomains(campaignId: string, limit?: number, cursor?: number, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getGeneratedDomains(campaignId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets HTTP keyword validation results for an HTTP keyword validation campaign
     * @summary Get HTTP keyword results
     * @param {string} campaignId Campaign UUID
     * @param {number} [limit] Maximum number of results to return
     * @param {string} [cursor] Cursor for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getHTTPKeywordResults(campaignId: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getHTTPKeywordResults(campaignId, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all campaigns with pagination and filtering support
     * @summary List campaigns
     * @param {number} [limit] Maximum number of campaigns to return (1-100)
     * @param {number} [offset] Number of campaigns to skip for pagination
     * @param {ListCampaignsStatusEnum} [status] Filter campaigns by status
     * @param {ListCampaignsTypeEnum} [type] Filter campaigns by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public listCampaigns(limit?: number, offset?: number, status?: ListCampaignsStatusEnum, type?: ListCampaignsTypeEnum, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).listCampaigns(limit, offset, status, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pauses a running or queued campaign
     * @summary Pause campaign
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public pauseCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).pauseCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a paused campaign by queuing it for execution
     * @summary Resume campaign
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public resumeCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).resumeCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a campaign by transitioning it from pending to queued status
     * @summary Start campaign
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public startCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).startCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers domain-centric DNS validation for all domains in a completed domain generation campaign
     * @summary Validate DNS for campaign domains
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public validateDNSForCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).validateDNSForCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers domain-centric HTTP keyword validation for all domains in a completed DNS validation campaign
     * @summary Validate HTTP for campaign domains
     * @param {string} campaignId Campaign UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public validateHTTPForCampaign(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).validateHTTPForCampaign(campaignId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListCampaignsStatusEnum = {
    Pending: 'pending',
    Queued: 'queued',
    Running: 'running',
    Pausing: 'pausing',
    Paused: 'paused',
    Completed: 'completed',
    Failed: 'failed',
    Archived: 'archived',
    Cancelled: 'cancelled'
} as const;
export type ListCampaignsStatusEnum = typeof ListCampaignsStatusEnum[keyof typeof ListCampaignsStatusEnum];
/**
 * @export
 */
export const ListCampaignsTypeEnum = {
    DomainGeneration: 'domain_generation',
    DnsValidation: 'dns_validation',
    HttpKeywordValidation: 'http_keyword_validation'
} as const;
export type ListCampaignsTypeEnum = typeof ListCampaignsTypeEnum[keyof typeof ListCampaignsTypeEnum];


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns current feature flag settings
         * @summary Get feature flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates feature flag settings
         * @summary Update feature flags
         * @param {FeatureFlags} featureFlags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureFlags: async (featureFlags: FeatureFlags, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureFlags' is not null or undefined
            assertParamExists('updateFeatureFlags', 'featureFlags', featureFlags)
            const localVarPath = `/config/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(featureFlags, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns current feature flag settings
         * @summary Get feature flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureFlags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.getFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates feature flag settings
         * @summary Update feature flags
         * @param {FeatureFlags} featureFlags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeatureFlags(featureFlags: FeatureFlags, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeatureFlags(featureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigApi.updateFeatureFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * Returns current feature flag settings
         * @summary Get feature flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags(options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlags> {
            return localVarFp.getFeatureFlags(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates feature flag settings
         * @summary Update feature flags
         * @param {FeatureFlags} featureFlags 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeatureFlags(featureFlags: FeatureFlags, options?: RawAxiosRequestConfig): AxiosPromise<FeatureFlags> {
            return localVarFp.updateFeatureFlags(featureFlags, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * Returns current feature flag settings
     * @summary Get feature flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getFeatureFlags(options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getFeatureFlags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates feature flag settings
     * @summary Update feature flags
     * @param {FeatureFlags} featureFlags 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public updateFeatureFlags(featureFlags: FeatureFlags, options?: RawAxiosRequestConfig) {
        return ConfigApiFp(this.configuration).updateFeatureFlags(featureFlags, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves sanitized authentication configuration
         * @summary Get authentication configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the default DNS validator configuration
         * @summary Get DNS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the default HTTP validator configuration
         * @summary Get HTTP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTTPConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/http`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current logging configuration
         * @summary Get logging configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggingConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/logging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves proxy manager settings
         * @summary Get proxy manager configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyManagerConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/proxy-manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves global rate limiter settings
         * @summary Get rate limiter configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimiterConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/rate-limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves current server-wide configurations
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the worker configuration
         * @summary Get worker configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/config/worker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates authentication configuration
         * @summary Update authentication configuration
         * @param {AuthConfig} authConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthConfig: async (authConfig: AuthConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authConfig' is not null or undefined
            assertParamExists('updateAuthConfig', 'authConfig', authConfig)
            const localVarPath = `/api/v2/config/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the default DNS validator configuration
         * @summary Update DNS configuration
         * @param {DNSConfig} dNSConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNSConfig: async (dNSConfig: DNSConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dNSConfig' is not null or undefined
            assertParamExists('updateDNSConfig', 'dNSConfig', dNSConfig)
            const localVarPath = `/api/v2/config/dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dNSConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the default HTTP validator configuration
         * @summary Update HTTP configuration
         * @param {HTTPConfig} hTTPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHTTPConfig: async (hTTPConfig: HTTPConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hTTPConfig' is not null or undefined
            assertParamExists('updateHTTPConfig', 'hTTPConfig', hTTPConfig)
            const localVarPath = `/api/v2/config/http`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the logging configuration
         * @summary Update logging configuration
         * @param {LoggingConfig} loggingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggingConfig: async (loggingConfig: LoggingConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loggingConfig' is not null or undefined
            assertParamExists('updateLoggingConfig', 'loggingConfig', loggingConfig)
            const localVarPath = `/api/v2/config/logging`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loggingConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates proxy manager settings
         * @summary Update proxy manager configuration
         * @param {ProxyManagerConfig} proxyManagerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxyManagerConfig: async (proxyManagerConfig: ProxyManagerConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyManagerConfig' is not null or undefined
            assertParamExists('updateProxyManagerConfig', 'proxyManagerConfig', proxyManagerConfig)
            const localVarPath = `/api/v2/config/proxy-manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proxyManagerConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates global rate limiter settings
         * @summary Update rate limiter configuration
         * @param {RateLimiterConfig} rateLimiterConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRateLimiterConfig: async (rateLimiterConfig: RateLimiterConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateLimiterConfig' is not null or undefined
            assertParamExists('updateRateLimiterConfig', 'rateLimiterConfig', rateLimiterConfig)
            const localVarPath = `/api/v2/config/rate-limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateLimiterConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates server-wide configurations
         * @summary Update server configuration
         * @param {ServerConfig} serverConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServerConfig: async (serverConfig: ServerConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverConfig' is not null or undefined
            assertParamExists('updateServerConfig', 'serverConfig', serverConfig)
            const localVarPath = `/api/v2/config/server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serverConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the worker configuration
         * @summary Update worker configuration
         * @param {WorkerConfig} workerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkerConfig: async (workerConfig: WorkerConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerConfig' is not null or undefined
            assertParamExists('updateWorkerConfig', 'workerConfig', workerConfig)
            const localVarPath = `/api/v2/config/worker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workerConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves sanitized authentication configuration
         * @summary Get authentication configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getAuthConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the default DNS validator configuration
         * @summary Get DNS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDNSConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDNSConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getDNSConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the default HTTP validator configuration
         * @summary Get HTTP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHTTPConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHTTPConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getHTTPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the current logging configuration
         * @summary Get logging configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggingConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoggingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoggingConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getLoggingConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves proxy manager settings
         * @summary Get proxy manager configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxyManagerConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyManagerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxyManagerConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getProxyManagerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves global rate limiter settings
         * @summary Get rate limiter configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimiterConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateLimiterConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimiterConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getRateLimiterConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves current server-wide configurations
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getServerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the worker configuration
         * @summary Get worker configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkerConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkerConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.getWorkerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates authentication configuration
         * @summary Update authentication configuration
         * @param {AuthConfig} authConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuthConfig(authConfig: AuthConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAuthConfig(authConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateAuthConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the default DNS validator configuration
         * @summary Update DNS configuration
         * @param {DNSConfig} dNSConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDNSConfig(dNSConfig: DNSConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DNSConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDNSConfig(dNSConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateDNSConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the default HTTP validator configuration
         * @summary Update HTTP configuration
         * @param {HTTPConfig} hTTPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHTTPConfig(hTTPConfig: HTTPConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHTTPConfig(hTTPConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateHTTPConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the logging configuration
         * @summary Update logging configuration
         * @param {LoggingConfig} loggingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoggingConfig(loggingConfig: LoggingConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoggingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLoggingConfig(loggingConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateLoggingConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates proxy manager settings
         * @summary Update proxy manager configuration
         * @param {ProxyManagerConfig} proxyManagerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProxyManagerConfig(proxyManagerConfig: ProxyManagerConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyManagerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProxyManagerConfig(proxyManagerConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateProxyManagerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates global rate limiter settings
         * @summary Update rate limiter configuration
         * @param {RateLimiterConfig} rateLimiterConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRateLimiterConfig(rateLimiterConfig: RateLimiterConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateLimiterConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRateLimiterConfig(rateLimiterConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateRateLimiterConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates server-wide configurations
         * @summary Update server configuration
         * @param {ServerConfig} serverConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServerConfig(serverConfig: ServerConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServerConfig(serverConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateServerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the worker configuration
         * @summary Update worker configuration
         * @param {WorkerConfig} workerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkerConfig(workerConfig: WorkerConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkerConfig(workerConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigurationApi.updateWorkerConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigurationApiFp(configuration)
    return {
        /**
         * Retrieves sanitized authentication configuration
         * @summary Get authentication configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthConfig(options?: RawAxiosRequestConfig): AxiosPromise<AuthConfig> {
            return localVarFp.getAuthConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the default DNS validator configuration
         * @summary Get DNS configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDNSConfig(options?: RawAxiosRequestConfig): AxiosPromise<DNSConfig> {
            return localVarFp.getDNSConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the default HTTP validator configuration
         * @summary Get HTTP configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHTTPConfig(options?: RawAxiosRequestConfig): AxiosPromise<HTTPConfig> {
            return localVarFp.getHTTPConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the current logging configuration
         * @summary Get logging configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggingConfig(options?: RawAxiosRequestConfig): AxiosPromise<LoggingConfig> {
            return localVarFp.getLoggingConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves proxy manager settings
         * @summary Get proxy manager configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyManagerConfig(options?: RawAxiosRequestConfig): AxiosPromise<ProxyManagerConfig> {
            return localVarFp.getProxyManagerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves global rate limiter settings
         * @summary Get rate limiter configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimiterConfig(options?: RawAxiosRequestConfig): AxiosPromise<RateLimiterConfig> {
            return localVarFp.getRateLimiterConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves current server-wide configurations
         * @summary Get server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerConfig(options?: RawAxiosRequestConfig): AxiosPromise<ServerConfig> {
            return localVarFp.getServerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the worker configuration
         * @summary Get worker configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerConfig(options?: RawAxiosRequestConfig): AxiosPromise<WorkerConfig> {
            return localVarFp.getWorkerConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates authentication configuration
         * @summary Update authentication configuration
         * @param {AuthConfig} authConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthConfig(authConfig: AuthConfig, options?: RawAxiosRequestConfig): AxiosPromise<AuthConfig> {
            return localVarFp.updateAuthConfig(authConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the default DNS validator configuration
         * @summary Update DNS configuration
         * @param {DNSConfig} dNSConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDNSConfig(dNSConfig: DNSConfig, options?: RawAxiosRequestConfig): AxiosPromise<DNSConfig> {
            return localVarFp.updateDNSConfig(dNSConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the default HTTP validator configuration
         * @summary Update HTTP configuration
         * @param {HTTPConfig} hTTPConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHTTPConfig(hTTPConfig: HTTPConfig, options?: RawAxiosRequestConfig): AxiosPromise<HTTPConfig> {
            return localVarFp.updateHTTPConfig(hTTPConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the logging configuration
         * @summary Update logging configuration
         * @param {LoggingConfig} loggingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggingConfig(loggingConfig: LoggingConfig, options?: RawAxiosRequestConfig): AxiosPromise<LoggingConfig> {
            return localVarFp.updateLoggingConfig(loggingConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates proxy manager settings
         * @summary Update proxy manager configuration
         * @param {ProxyManagerConfig} proxyManagerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxyManagerConfig(proxyManagerConfig: ProxyManagerConfig, options?: RawAxiosRequestConfig): AxiosPromise<ProxyManagerConfig> {
            return localVarFp.updateProxyManagerConfig(proxyManagerConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates global rate limiter settings
         * @summary Update rate limiter configuration
         * @param {RateLimiterConfig} rateLimiterConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRateLimiterConfig(rateLimiterConfig: RateLimiterConfig, options?: RawAxiosRequestConfig): AxiosPromise<RateLimiterConfig> {
            return localVarFp.updateRateLimiterConfig(rateLimiterConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates server-wide configurations
         * @summary Update server configuration
         * @param {ServerConfig} serverConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServerConfig(serverConfig: ServerConfig, options?: RawAxiosRequestConfig): AxiosPromise<ServerConfig> {
            return localVarFp.updateServerConfig(serverConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the worker configuration
         * @summary Update worker configuration
         * @param {WorkerConfig} workerConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkerConfig(workerConfig: WorkerConfig, options?: RawAxiosRequestConfig): AxiosPromise<WorkerConfig> {
            return localVarFp.updateWorkerConfig(workerConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * Retrieves sanitized authentication configuration
     * @summary Get authentication configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getAuthConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getAuthConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the default DNS validator configuration
     * @summary Get DNS configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getDNSConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getDNSConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the default HTTP validator configuration
     * @summary Get HTTP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getHTTPConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getHTTPConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the current logging configuration
     * @summary Get logging configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getLoggingConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getLoggingConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves proxy manager settings
     * @summary Get proxy manager configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getProxyManagerConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getProxyManagerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves global rate limiter settings
     * @summary Get rate limiter configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getRateLimiterConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getRateLimiterConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves current server-wide configurations
     * @summary Get server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getServerConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getServerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the worker configuration
     * @summary Get worker configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getWorkerConfig(options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).getWorkerConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates authentication configuration
     * @summary Update authentication configuration
     * @param {AuthConfig} authConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateAuthConfig(authConfig: AuthConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateAuthConfig(authConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the default DNS validator configuration
     * @summary Update DNS configuration
     * @param {DNSConfig} dNSConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateDNSConfig(dNSConfig: DNSConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateDNSConfig(dNSConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the default HTTP validator configuration
     * @summary Update HTTP configuration
     * @param {HTTPConfig} hTTPConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateHTTPConfig(hTTPConfig: HTTPConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateHTTPConfig(hTTPConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the logging configuration
     * @summary Update logging configuration
     * @param {LoggingConfig} loggingConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateLoggingConfig(loggingConfig: LoggingConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateLoggingConfig(loggingConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates proxy manager settings
     * @summary Update proxy manager configuration
     * @param {ProxyManagerConfig} proxyManagerConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateProxyManagerConfig(proxyManagerConfig: ProxyManagerConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateProxyManagerConfig(proxyManagerConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates global rate limiter settings
     * @summary Update rate limiter configuration
     * @param {RateLimiterConfig} rateLimiterConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateRateLimiterConfig(rateLimiterConfig: RateLimiterConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateRateLimiterConfig(rateLimiterConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates server-wide configurations
     * @summary Update server configuration
     * @param {ServerConfig} serverConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateServerConfig(serverConfig: ServerConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateServerConfig(serverConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the worker configuration
     * @summary Update worker configuration
     * @param {WorkerConfig} workerConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateWorkerConfig(workerConfig: WorkerConfig, options?: RawAxiosRequestConfig) {
        return ConfigurationApiFp(this.configuration).updateWorkerConfig(workerConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns overall health status of the application and its components
         * @summary Basic health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the service is alive and running
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivenessCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the service is ready to receive traffic
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadinessCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns overall health status of the application and its components
         * @summary Basic health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getHealthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the service is alive and running
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLivenessCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLivenessCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getLivenessCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the service is ready to receive traffic
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReadinessCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReadinessCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getReadinessCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Returns overall health status of the application and its components
         * @summary Basic health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.getHealthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the service is alive and running
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLivenessCheck(options?: RawAxiosRequestConfig): AxiosPromise<SimpleStatus> {
            return localVarFp.getLivenessCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the service is ready to receive traffic
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReadinessCheck(options?: RawAxiosRequestConfig): AxiosPromise<SimpleStatus> {
            return localVarFp.getReadinessCheck(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Returns overall health status of the application and its components
     * @summary Basic health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the service is alive and running
     * @summary Liveness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getLivenessCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getLivenessCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the service is ready to receive traffic
     * @summary Readiness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getReadinessCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getReadinessCheck(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordSetsApi - axios parameter creator
 * @export
 */
export const KeywordSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new keyword set with optional rules
         * @summary Create keyword set
         * @param {CreateKeywordSetRequest} createKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeywordSet: async (createKeywordSetRequest: CreateKeywordSetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createKeywordSetRequest' is not null or undefined
            assertParamExists('createKeywordSet', 'createKeywordSetRequest', createKeywordSetRequest)
            const localVarPath = `/keywords/sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKeywordSetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a keyword set by ID including all its rules
         * @summary Delete keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeywordSet: async (setId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('deleteKeywordSet', 'setId', setId)
            const localVarPath = `/keywords/sets/{setId}`
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a keyword set by ID including its rules
         * @summary Get keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywordSet: async (setId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('getKeywordSet', 'setId', setId)
            const localVarPath = `/keywords/sets/{setId}`
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all keyword sets with optional filtering and pagination
         * @summary List keyword sets
         * @param {number} [limit] Maximum number of keyword sets to return
         * @param {number} [offset] Number of keyword sets to skip for pagination
         * @param {boolean} [isEnabled] Filter keyword sets by enabled status
         * @param {boolean} [includeRules] Include keyword rules in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywordSets: async (limit?: number, offset?: number, isEnabled?: boolean, includeRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keywords/sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }

            if (includeRules !== undefined) {
                localVarQueryParameter['includeRules'] = includeRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a keyword set by ID including its rules
         * @summary Update keyword set
         * @param {string} setId Keyword set ID
         * @param {UpdateKeywordSetRequest} updateKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeywordSet: async (setId: string, updateKeywordSetRequest: UpdateKeywordSetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('updateKeywordSet', 'setId', setId)
            // verify required parameter 'updateKeywordSetRequest' is not null or undefined
            assertParamExists('updateKeywordSet', 'updateKeywordSetRequest', updateKeywordSetRequest)
            const localVarPath = `/keywords/sets/{setId}`
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateKeywordSetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordSetsApi - functional programming interface
 * @export
 */
export const KeywordSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new keyword set with optional rules
         * @summary Create keyword set
         * @param {CreateKeywordSetRequest} createKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKeywordSet(createKeywordSetRequest: CreateKeywordSetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKeywordSet(createKeywordSetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSetsApi.createKeywordSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a keyword set by ID including all its rules
         * @summary Delete keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKeywordSet(setId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKeywordSet(setId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSetsApi.deleteKeywordSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a keyword set by ID including its rules
         * @summary Get keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeywordSet(setId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywordSet(setId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSetsApi.getKeywordSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all keyword sets with optional filtering and pagination
         * @summary List keyword sets
         * @param {number} [limit] Maximum number of keyword sets to return
         * @param {number} [offset] Number of keyword sets to skip for pagination
         * @param {boolean} [isEnabled] Filter keyword sets by enabled status
         * @param {boolean} [includeRules] Include keyword rules in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeywordSets(limit?: number, offset?: number, isEnabled?: boolean, includeRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeywordSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeywordSets(limit, offset, isEnabled, includeRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSetsApi.listKeywordSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a keyword set by ID including its rules
         * @summary Update keyword set
         * @param {string} setId Keyword set ID
         * @param {UpdateKeywordSetRequest} updateKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeywordSet(setId: string, updateKeywordSetRequest: UpdateKeywordSetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeywordSet(setId, updateKeywordSetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordSetsApi.updateKeywordSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordSetsApi - factory interface
 * @export
 */
export const KeywordSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordSetsApiFp(configuration)
    return {
        /**
         * Creates a new keyword set with optional rules
         * @summary Create keyword set
         * @param {CreateKeywordSetRequest} createKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeywordSet(createKeywordSetRequest: CreateKeywordSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeywordSet> {
            return localVarFp.createKeywordSet(createKeywordSetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a keyword set by ID including all its rules
         * @summary Delete keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeywordSet(setId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteKeywordSet(setId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a keyword set by ID including its rules
         * @summary Get keyword set
         * @param {string} setId Keyword set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeywordSet(setId: string, options?: RawAxiosRequestConfig): AxiosPromise<KeywordSet> {
            return localVarFp.getKeywordSet(setId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all keyword sets with optional filtering and pagination
         * @summary List keyword sets
         * @param {number} [limit] Maximum number of keyword sets to return
         * @param {number} [offset] Number of keyword sets to skip for pagination
         * @param {boolean} [isEnabled] Filter keyword sets by enabled status
         * @param {boolean} [includeRules] Include keyword rules in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywordSets(limit?: number, offset?: number, isEnabled?: boolean, includeRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<KeywordSet>> {
            return localVarFp.listKeywordSets(limit, offset, isEnabled, includeRules, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a keyword set by ID including its rules
         * @summary Update keyword set
         * @param {string} setId Keyword set ID
         * @param {UpdateKeywordSetRequest} updateKeywordSetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeywordSet(setId: string, updateKeywordSetRequest: UpdateKeywordSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeywordSet> {
            return localVarFp.updateKeywordSet(setId, updateKeywordSetRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeywordSetsApi - object-oriented interface
 * @export
 * @class KeywordSetsApi
 * @extends {BaseAPI}
 */
export class KeywordSetsApi extends BaseAPI {
    /**
     * Creates a new keyword set with optional rules
     * @summary Create keyword set
     * @param {CreateKeywordSetRequest} createKeywordSetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSetsApi
     */
    public createKeywordSet(createKeywordSetRequest: CreateKeywordSetRequest, options?: RawAxiosRequestConfig) {
        return KeywordSetsApiFp(this.configuration).createKeywordSet(createKeywordSetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a keyword set by ID including all its rules
     * @summary Delete keyword set
     * @param {string} setId Keyword set ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSetsApi
     */
    public deleteKeywordSet(setId: string, options?: RawAxiosRequestConfig) {
        return KeywordSetsApiFp(this.configuration).deleteKeywordSet(setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a keyword set by ID including its rules
     * @summary Get keyword set
     * @param {string} setId Keyword set ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSetsApi
     */
    public getKeywordSet(setId: string, options?: RawAxiosRequestConfig) {
        return KeywordSetsApiFp(this.configuration).getKeywordSet(setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all keyword sets with optional filtering and pagination
     * @summary List keyword sets
     * @param {number} [limit] Maximum number of keyword sets to return
     * @param {number} [offset] Number of keyword sets to skip for pagination
     * @param {boolean} [isEnabled] Filter keyword sets by enabled status
     * @param {boolean} [includeRules] Include keyword rules in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSetsApi
     */
    public listKeywordSets(limit?: number, offset?: number, isEnabled?: boolean, includeRules?: boolean, options?: RawAxiosRequestConfig) {
        return KeywordSetsApiFp(this.configuration).listKeywordSets(limit, offset, isEnabled, includeRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a keyword set by ID including its rules
     * @summary Update keyword set
     * @param {string} setId Keyword set ID
     * @param {UpdateKeywordSetRequest} updateKeywordSetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordSetsApi
     */
    public updateKeywordSet(setId: string, updateKeywordSetRequest: UpdateKeywordSetRequest, options?: RawAxiosRequestConfig) {
        return KeywordSetsApiFp(this.configuration).updateKeywordSet(setId, updateKeywordSetRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordsApi - axios parameter creator
 * @export
 */
export const KeywordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Extracts keywords from multiple URLs in a single batch request
         * @summary Batch keyword extraction
         * @param {BatchKeywordExtractionRequest} batchKeywordExtractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchExtractKeywords: async (batchKeywordExtractionRequest: BatchKeywordExtractionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchKeywordExtractionRequest' is not null or undefined
            assertParamExists('batchExtractKeywords', 'batchKeywordExtractionRequest', batchKeywordExtractionRequest)
            const localVarPath = `/api/v2/extract/keywords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchKeywordExtractionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extracts keywords from a single URL with real-time streaming results
         * @summary Streaming keyword extraction
         * @param {string} url URL to extract keywords from
         * @param {string} keywordSetId UUID of the keyword set to use for extraction
         * @param {string} [httpPersonaId] Optional UUID of HTTP persona to use
         * @param {string} [dnsPersonaId] Optional UUID of DNS persona to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamExtractKeywords: async (url: string, keywordSetId: string, httpPersonaId?: string, dnsPersonaId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('streamExtractKeywords', 'url', url)
            // verify required parameter 'keywordSetId' is not null or undefined
            assertParamExists('streamExtractKeywords', 'keywordSetId', keywordSetId)
            const localVarPath = `/api/v2/extract/keywords/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (keywordSetId !== undefined) {
                localVarQueryParameter['keywordSetId'] = keywordSetId;
            }

            if (httpPersonaId !== undefined) {
                localVarQueryParameter['httpPersonaId'] = httpPersonaId;
            }

            if (dnsPersonaId !== undefined) {
                localVarQueryParameter['dnsPersonaId'] = dnsPersonaId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordsApi - functional programming interface
 * @export
 */
export const KeywordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordsApiAxiosParamCreator(configuration)
    return {
        /**
         * Extracts keywords from multiple URLs in a single batch request
         * @summary Batch keyword extraction
         * @param {BatchKeywordExtractionRequest} batchKeywordExtractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchExtractKeywords(batchKeywordExtractionRequest: BatchKeywordExtractionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchKeywordExtractionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchExtractKeywords(batchKeywordExtractionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.batchExtractKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extracts keywords from a single URL with real-time streaming results
         * @summary Streaming keyword extraction
         * @param {string} url URL to extract keywords from
         * @param {string} keywordSetId UUID of the keyword set to use for extraction
         * @param {string} [httpPersonaId] Optional UUID of HTTP persona to use
         * @param {string} [dnsPersonaId] Optional UUID of DNS persona to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamExtractKeywords(url: string, keywordSetId: string, httpPersonaId?: string, dnsPersonaId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamExtractKeywords(url, keywordSetId, httpPersonaId, dnsPersonaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.streamExtractKeywords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordsApi - factory interface
 * @export
 */
export const KeywordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordsApiFp(configuration)
    return {
        /**
         * Extracts keywords from multiple URLs in a single batch request
         * @summary Batch keyword extraction
         * @param {BatchKeywordExtractionRequest} batchKeywordExtractionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchExtractKeywords(batchKeywordExtractionRequest: BatchKeywordExtractionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchKeywordExtractionResponse> {
            return localVarFp.batchExtractKeywords(batchKeywordExtractionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Extracts keywords from a single URL with real-time streaming results
         * @summary Streaming keyword extraction
         * @param {string} url URL to extract keywords from
         * @param {string} keywordSetId UUID of the keyword set to use for extraction
         * @param {string} [httpPersonaId] Optional UUID of HTTP persona to use
         * @param {string} [dnsPersonaId] Optional UUID of DNS persona to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamExtractKeywords(url: string, keywordSetId: string, httpPersonaId?: string, dnsPersonaId?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.streamExtractKeywords(url, keywordSetId, httpPersonaId, dnsPersonaId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeywordsApi - object-oriented interface
 * @export
 * @class KeywordsApi
 * @extends {BaseAPI}
 */
export class KeywordsApi extends BaseAPI {
    /**
     * Extracts keywords from multiple URLs in a single batch request
     * @summary Batch keyword extraction
     * @param {BatchKeywordExtractionRequest} batchKeywordExtractionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public batchExtractKeywords(batchKeywordExtractionRequest: BatchKeywordExtractionRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).batchExtractKeywords(batchKeywordExtractionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extracts keywords from a single URL with real-time streaming results
     * @summary Streaming keyword extraction
     * @param {string} url URL to extract keywords from
     * @param {string} keywordSetId UUID of the keyword set to use for extraction
     * @param {string} [httpPersonaId] Optional UUID of HTTP persona to use
     * @param {string} [dnsPersonaId] Optional UUID of DNS persona to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public streamExtractKeywords(url: string, keywordSetId: string, httpPersonaId?: string, dnsPersonaId?: string, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).streamExtractKeywords(url, keywordSetId, httpPersonaId, dnsPersonaId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonasApi - axios parameter creator
 * @export
 */
export const PersonasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new persona with structured configuration
         * @summary Create persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona: async (createPersonaRequest: CreatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonaRequest' is not null or undefined
            assertParamExists('createPersona', 'createPersonaRequest', createPersonaRequest)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a persona by ID
         * @summary Delete persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePersona', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a DNS persona by ID with typed configuration
         * @summary Get DNS persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsPersonaById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDnsPersonaById', 'id', id)
            const localVarPath = `/personas/dns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an HTTP persona by ID with typed configuration
         * @summary Get HTTP persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHttpPersonaById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHttpPersonaById', 'id', id)
            const localVarPath = `/personas/http/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a persona by ID regardless of type
         * @summary Get persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPersonaById', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all personas with optional filtering by type and enabled status
         * @summary List personas
         * @param {number} [limit] Maximum number of personas to return
         * @param {number} [offset] Number of personas to skip for pagination
         * @param {ListPersonasPersonaTypeEnum} [personaType] Filter personas by type
         * @param {boolean} [isEnabled] Filter personas by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas: async (limit?: number, offset?: number, personaType?: ListPersonasPersonaTypeEnum, isEnabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (personaType !== undefined) {
                localVarQueryParameter['personaType'] = personaType;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests a persona by ID
         * @summary Test persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPersona: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('testPersona', 'id', id)
            const localVarPath = `/personas/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a persona by ID with structured configuration
         * @summary Update persona
         * @param {string} id Persona ID
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona: async (id: string, updatePersonaRequest: UpdatePersonaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePersona', 'id', id)
            // verify required parameter 'updatePersonaRequest' is not null or undefined
            assertParamExists('updatePersona', 'updatePersonaRequest', updatePersonaRequest)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonasApi - functional programming interface
 * @export
 */
export const PersonasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonasApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new persona with structured configuration
         * @summary Create persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.createPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a persona by ID
         * @summary Delete persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePersona(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StandardAPIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.deletePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a DNS persona by ID with typed configuration
         * @summary Get DNS persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDnsPersonaById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDnsPersonaById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.getDnsPersonaById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets an HTTP persona by ID with typed configuration
         * @summary Get HTTP persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHttpPersonaById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHttpPersonaById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.getHttpPersonaById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a persona by ID regardless of type
         * @summary Get persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonaById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonaById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.getPersonaById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all personas with optional filtering by type and enabled status
         * @summary List personas
         * @param {number} [limit] Maximum number of personas to return
         * @param {number} [offset] Number of personas to skip for pagination
         * @param {ListPersonasPersonaTypeEnum} [personaType] Filter personas by type
         * @param {boolean} [isEnabled] Filter personas by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPersonas(limit?: number, offset?: number, personaType?: ListPersonasPersonaTypeEnum, isEnabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(limit, offset, personaType, isEnabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.listPersonas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Tests a persona by ID
         * @summary Test persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPersona(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaTestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPersona(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.testPersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a persona by ID with structured configuration
         * @summary Update persona
         * @param {string} id Persona ID
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePersona(id: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(id, updatePersonaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonasApi.updatePersona']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonasApi - factory interface
 * @export
 */
export const PersonasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonasApiFp(configuration)
    return {
        /**
         * Creates a new persona with structured configuration
         * @summary Create persona
         * @param {CreatePersonaRequest} createPersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.createPersona(createPersonaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a persona by ID
         * @summary Delete persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersona(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StandardAPIResponse> {
            return localVarFp.deletePersona(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a DNS persona by ID with typed configuration
         * @summary Get DNS persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsPersonaById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getDnsPersonaById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an HTTP persona by ID with typed configuration
         * @summary Get HTTP persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHttpPersonaById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getHttpPersonaById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a persona by ID regardless of type
         * @summary Get persona by ID
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.getPersonaById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all personas with optional filtering by type and enabled status
         * @summary List personas
         * @param {number} [limit] Maximum number of personas to return
         * @param {number} [offset] Number of personas to skip for pagination
         * @param {ListPersonasPersonaTypeEnum} [personaType] Filter personas by type
         * @param {boolean} [isEnabled] Filter personas by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPersonas(limit?: number, offset?: number, personaType?: ListPersonasPersonaTypeEnum, isEnabled?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PersonaListResponse> {
            return localVarFp.listPersonas(limit, offset, personaType, isEnabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests a persona by ID
         * @summary Test persona
         * @param {string} id Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPersona(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonaTestResult> {
            return localVarFp.testPersona(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a persona by ID with structured configuration
         * @summary Update persona
         * @param {string} id Persona ID
         * @param {UpdatePersonaRequest} updatePersonaRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersona(id: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {
            return localVarFp.updatePersona(id, updatePersonaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonasApi - object-oriented interface
 * @export
 * @class PersonasApi
 * @extends {BaseAPI}
 */
export class PersonasApi extends BaseAPI {
    /**
     * Creates a new persona with structured configuration
     * @summary Create persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public createPersona(createPersonaRequest: CreatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).createPersona(createPersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a persona by ID
     * @summary Delete persona
     * @param {string} id Persona ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public deletePersona(id: string, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).deletePersona(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a DNS persona by ID with typed configuration
     * @summary Get DNS persona by ID
     * @param {string} id Persona ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getDnsPersonaById(id: string, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getDnsPersonaById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an HTTP persona by ID with typed configuration
     * @summary Get HTTP persona by ID
     * @param {string} id Persona ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getHttpPersonaById(id: string, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getHttpPersonaById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a persona by ID regardless of type
     * @summary Get persona by ID
     * @param {string} id Persona ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public getPersonaById(id: string, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getPersonaById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all personas with optional filtering by type and enabled status
     * @summary List personas
     * @param {number} [limit] Maximum number of personas to return
     * @param {number} [offset] Number of personas to skip for pagination
     * @param {ListPersonasPersonaTypeEnum} [personaType] Filter personas by type
     * @param {boolean} [isEnabled] Filter personas by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public listPersonas(limit?: number, offset?: number, personaType?: ListPersonasPersonaTypeEnum, isEnabled?: boolean, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).listPersonas(limit, offset, personaType, isEnabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests a persona by ID
     * @summary Test persona
     * @param {string} id Persona ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public testPersona(id: string, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).testPersona(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a persona by ID with structured configuration
     * @summary Update persona
     * @param {string} id Persona ID
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApi
     */
    public updatePersona(id: string, updatePersonaRequest: UpdatePersonaRequest, options?: RawAxiosRequestConfig) {
        return PersonasApiFp(this.configuration).updatePersona(id, updatePersonaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPersonasPersonaTypeEnum = {
    Dns: 'dns',
    Http: 'http'
} as const;
export type ListPersonasPersonaTypeEnum = typeof ListPersonasPersonaTypeEnum[keyof typeof ListPersonasPersonaTypeEnum];


/**
 * ProxiesApi - axios parameter creator
 * @export
 */
export const ProxiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new proxy
         * @summary Add proxy
         * @param {CreateProxyRequest} createProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProxy: async (createProxyRequest: CreateProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProxyRequest' is not null or undefined
            assertParamExists('createProxy', 'createProxyRequest', createProxyRequest)
            const localVarPath = `/proxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a proxy by ID
         * @summary Delete proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProxy: async (proxyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyId' is not null or undefined
            assertParamExists('deleteProxy', 'proxyId', proxyId)
            const localVarPath = `/proxies/{proxyId}`
                .replace(`{${"proxyId"}}`, encodeURIComponent(String(proxyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forces a health check on all proxies
         * @summary Force all proxies health check
         * @param {ForceCheckProxiesRequest} [forceCheckProxiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceCheckAllProxies: async (forceCheckProxiesRequest?: ForceCheckProxiesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proxies/health-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forceCheckProxiesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forces a health check on a single proxy
         * @summary Force single proxy health check
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceCheckSingleProxy: async (proxyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyId' is not null or undefined
            assertParamExists('forceCheckSingleProxy', 'proxyId', proxyId)
            const localVarPath = `/proxies/{proxyId}/health-check`
                .replace(`{${"proxyId"}}`, encodeURIComponent(String(proxyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the status of all proxies
         * @summary Get proxy statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyStatuses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proxies/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all proxies with optional filtering
         * @summary List proxies
         * @param {number} [limit] Number of items to return
         * @param {number} [offset] Number of items to skip
         * @param {ListProxiesProtocolEnum} [protocol] Filter by proxy protocol
         * @param {boolean} [isEnabled] Filter by enabled status
         * @param {boolean} [isHealthy] Filter by health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProxies: async (limit?: number, offset?: number, protocol?: ListProxiesProtocolEnum, isEnabled?: boolean, isHealthy?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }

            if (isHealthy !== undefined) {
                localVarQueryParameter['isHealthy'] = isHealthy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests a proxy by ID
         * @summary Test proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testProxy: async (proxyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyId' is not null or undefined
            assertParamExists('testProxy', 'proxyId', proxyId)
            const localVarPath = `/proxies/{proxyId}/test`
                .replace(`{${"proxyId"}}`, encodeURIComponent(String(proxyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a proxy by ID
         * @summary Update proxy
         * @param {string} proxyId Proxy ID
         * @param {UpdateProxyRequest} updateProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxy: async (proxyId: string, updateProxyRequest: UpdateProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyId' is not null or undefined
            assertParamExists('updateProxy', 'proxyId', proxyId)
            // verify required parameter 'updateProxyRequest' is not null or undefined
            assertParamExists('updateProxy', 'updateProxyRequest', updateProxyRequest)
            const localVarPath = `/proxies/{proxyId}`
                .replace(`{${"proxyId"}}`, encodeURIComponent(String(proxyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxiesApi - functional programming interface
 * @export
 */
export const ProxiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new proxy
         * @summary Add proxy
         * @param {CreateProxyRequest} createProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProxy(createProxyRequest: CreateProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProxy(createProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.createProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a proxy by ID
         * @summary Delete proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProxy(proxyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProxy(proxyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.deleteProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Forces a health check on all proxies
         * @summary Force all proxies health check
         * @param {ForceCheckProxiesRequest} [forceCheckProxiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceCheckAllProxies(forceCheckProxiesRequest?: ForceCheckProxiesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForceCheckAllProxies202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceCheckAllProxies(forceCheckProxiesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.forceCheckAllProxies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Forces a health check on a single proxy
         * @summary Force single proxy health check
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceCheckSingleProxy(proxyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceCheckSingleProxy(proxyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.forceCheckSingleProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the status of all proxies
         * @summary Get proxy statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxyStatuses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProxyStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxyStatuses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.getProxyStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all proxies with optional filtering
         * @summary List proxies
         * @param {number} [limit] Number of items to return
         * @param {number} [offset] Number of items to skip
         * @param {ListProxiesProtocolEnum} [protocol] Filter by proxy protocol
         * @param {boolean} [isEnabled] Filter by enabled status
         * @param {boolean} [isHealthy] Filter by health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProxies(limit?: number, offset?: number, protocol?: ListProxiesProtocolEnum, isEnabled?: boolean, isHealthy?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Proxy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProxies(limit, offset, protocol, isEnabled, isHealthy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.listProxies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Tests a proxy by ID
         * @summary Test proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testProxy(proxyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyTestResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testProxy(proxyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.testProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a proxy by ID
         * @summary Update proxy
         * @param {string} proxyId Proxy ID
         * @param {UpdateProxyRequest} updateProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProxy(proxyId: string, updateProxyRequest: UpdateProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proxy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProxy(proxyId, updateProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxiesApi.updateProxy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProxiesApi - factory interface
 * @export
 */
export const ProxiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxiesApiFp(configuration)
    return {
        /**
         * Adds a new proxy
         * @summary Add proxy
         * @param {CreateProxyRequest} createProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProxy(createProxyRequest: CreateProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Proxy> {
            return localVarFp.createProxy(createProxyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a proxy by ID
         * @summary Delete proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProxy(proxyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProxy(proxyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Forces a health check on all proxies
         * @summary Force all proxies health check
         * @param {ForceCheckProxiesRequest} [forceCheckProxiesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceCheckAllProxies(forceCheckProxiesRequest?: ForceCheckProxiesRequest, options?: RawAxiosRequestConfig): AxiosPromise<ForceCheckAllProxies202Response> {
            return localVarFp.forceCheckAllProxies(forceCheckProxiesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Forces a health check on a single proxy
         * @summary Force single proxy health check
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceCheckSingleProxy(proxyId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProxyStatus> {
            return localVarFp.forceCheckSingleProxy(proxyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the status of all proxies
         * @summary Get proxy statuses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyStatuses(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProxyStatus>> {
            return localVarFp.getProxyStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all proxies with optional filtering
         * @summary List proxies
         * @param {number} [limit] Number of items to return
         * @param {number} [offset] Number of items to skip
         * @param {ListProxiesProtocolEnum} [protocol] Filter by proxy protocol
         * @param {boolean} [isEnabled] Filter by enabled status
         * @param {boolean} [isHealthy] Filter by health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProxies(limit?: number, offset?: number, protocol?: ListProxiesProtocolEnum, isEnabled?: boolean, isHealthy?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Proxy>> {
            return localVarFp.listProxies(limit, offset, protocol, isEnabled, isHealthy, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests a proxy by ID
         * @summary Test proxy
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testProxy(proxyId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProxyTestResult> {
            return localVarFp.testProxy(proxyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a proxy by ID
         * @summary Update proxy
         * @param {string} proxyId Proxy ID
         * @param {UpdateProxyRequest} updateProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxy(proxyId: string, updateProxyRequest: UpdateProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<Proxy> {
            return localVarFp.updateProxy(proxyId, updateProxyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxiesApi - object-oriented interface
 * @export
 * @class ProxiesApi
 * @extends {BaseAPI}
 */
export class ProxiesApi extends BaseAPI {
    /**
     * Adds a new proxy
     * @summary Add proxy
     * @param {CreateProxyRequest} createProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public createProxy(createProxyRequest: CreateProxyRequest, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).createProxy(createProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a proxy by ID
     * @summary Delete proxy
     * @param {string} proxyId Proxy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public deleteProxy(proxyId: string, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).deleteProxy(proxyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forces a health check on all proxies
     * @summary Force all proxies health check
     * @param {ForceCheckProxiesRequest} [forceCheckProxiesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public forceCheckAllProxies(forceCheckProxiesRequest?: ForceCheckProxiesRequest, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).forceCheckAllProxies(forceCheckProxiesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Forces a health check on a single proxy
     * @summary Force single proxy health check
     * @param {string} proxyId Proxy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public forceCheckSingleProxy(proxyId: string, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).forceCheckSingleProxy(proxyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the status of all proxies
     * @summary Get proxy statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public getProxyStatuses(options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).getProxyStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all proxies with optional filtering
     * @summary List proxies
     * @param {number} [limit] Number of items to return
     * @param {number} [offset] Number of items to skip
     * @param {ListProxiesProtocolEnum} [protocol] Filter by proxy protocol
     * @param {boolean} [isEnabled] Filter by enabled status
     * @param {boolean} [isHealthy] Filter by health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public listProxies(limit?: number, offset?: number, protocol?: ListProxiesProtocolEnum, isEnabled?: boolean, isHealthy?: boolean, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).listProxies(limit, offset, protocol, isEnabled, isHealthy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests a proxy by ID
     * @summary Test proxy
     * @param {string} proxyId Proxy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public testProxy(proxyId: string, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).testProxy(proxyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a proxy by ID
     * @summary Update proxy
     * @param {string} proxyId Proxy ID
     * @param {UpdateProxyRequest} updateProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxiesApi
     */
    public updateProxy(proxyId: string, updateProxyRequest: UpdateProxyRequest, options?: RawAxiosRequestConfig) {
        return ProxiesApiFp(this.configuration).updateProxy(proxyId, updateProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListProxiesProtocolEnum = {
    Http: 'http',
    Https: 'https',
    Socks5: 'socks5',
    Socks4: 'socks4'
} as const;
export type ListProxiesProtocolEnum = typeof ListProxiesProtocolEnum[keyof typeof ListProxiesProtocolEnum];


/**
 * ProxyPoolsApi - axios parameter creator
 * @export
 */
export const ProxyPoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a proxy to a pool
         * @summary Add proxy to pool
         * @param {string} poolId Pool ID
         * @param {AddProxyToPoolRequest} addProxyToPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProxyToPool: async (poolId: string, addProxyToPoolRequest: AddProxyToPoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('addProxyToPool', 'poolId', poolId)
            // verify required parameter 'addProxyToPoolRequest' is not null or undefined
            assertParamExists('addProxyToPool', 'addProxyToPoolRequest', addProxyToPoolRequest)
            const localVarPath = `/proxy-pools/{poolId}/proxies`
                .replace(`{${"poolId"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProxyToPoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new proxy pool
         * @summary Create proxy pool
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProxyPool: async (proxyPoolRequest: ProxyPoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proxyPoolRequest' is not null or undefined
            assertParamExists('createProxyPool', 'proxyPoolRequest', proxyPoolRequest)
            const localVarPath = `/proxy-pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proxyPoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a proxy pool by ID
         * @summary Delete proxy pool
         * @param {string} poolId Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProxyPool: async (poolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('deleteProxyPool', 'poolId', poolId)
            const localVarPath = `/proxy-pools/{poolId}`
                .replace(`{${"poolId"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all proxy pools
         * @summary List proxy pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProxyPools: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proxy-pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a proxy from a pool
         * @summary Remove proxy from pool
         * @param {string} poolId Pool ID
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProxyFromPool: async (poolId: string, proxyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('removeProxyFromPool', 'poolId', poolId)
            // verify required parameter 'proxyId' is not null or undefined
            assertParamExists('removeProxyFromPool', 'proxyId', proxyId)
            const localVarPath = `/proxy-pools/{poolId}/proxies/{proxyId}`
                .replace(`{${"poolId"}}`, encodeURIComponent(String(poolId)))
                .replace(`{${"proxyId"}}`, encodeURIComponent(String(proxyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a proxy pool by ID
         * @summary Update proxy pool
         * @param {string} poolId Pool ID
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxyPool: async (poolId: string, proxyPoolRequest: ProxyPoolRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'poolId' is not null or undefined
            assertParamExists('updateProxyPool', 'poolId', poolId)
            // verify required parameter 'proxyPoolRequest' is not null or undefined
            assertParamExists('updateProxyPool', 'proxyPoolRequest', proxyPoolRequest)
            const localVarPath = `/proxy-pools/{poolId}`
                .replace(`{${"poolId"}}`, encodeURIComponent(String(poolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proxyPoolRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyPoolsApi - functional programming interface
 * @export
 */
export const ProxyPoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyPoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a proxy to a pool
         * @summary Add proxy to pool
         * @param {string} poolId Pool ID
         * @param {AddProxyToPoolRequest} addProxyToPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProxyToPool(poolId: string, addProxyToPoolRequest: AddProxyToPoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyPoolMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProxyToPool(poolId, addProxyToPoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.addProxyToPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new proxy pool
         * @summary Create proxy pool
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProxyPool(proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProxyPool(proxyPoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.createProxyPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a proxy pool by ID
         * @summary Delete proxy pool
         * @param {string} poolId Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProxyPool(poolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProxyPool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProxyPool(poolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.deleteProxyPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all proxy pools
         * @summary List proxy pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProxyPools(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProxyPool>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProxyPools(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.listProxyPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a proxy from a pool
         * @summary Remove proxy from pool
         * @param {string} poolId Pool ID
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProxyFromPool(poolId: string, proxyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoveProxyFromPool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProxyFromPool(poolId, proxyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.removeProxyFromPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a proxy pool by ID
         * @summary Update proxy pool
         * @param {string} poolId Pool ID
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProxyPool(poolId: string, proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyPool>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProxyPool(poolId, proxyPoolRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyPoolsApi.updateProxyPool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProxyPoolsApi - factory interface
 * @export
 */
export const ProxyPoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyPoolsApiFp(configuration)
    return {
        /**
         * Assigns a proxy to a pool
         * @summary Add proxy to pool
         * @param {string} poolId Pool ID
         * @param {AddProxyToPoolRequest} addProxyToPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProxyToPool(poolId: string, addProxyToPoolRequest: AddProxyToPoolRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProxyPoolMembership> {
            return localVarFp.addProxyToPool(poolId, addProxyToPoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new proxy pool
         * @summary Create proxy pool
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProxyPool(proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProxyPool> {
            return localVarFp.createProxyPool(proxyPoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a proxy pool by ID
         * @summary Delete proxy pool
         * @param {string} poolId Pool ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProxyPool(poolId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteProxyPool200Response> {
            return localVarFp.deleteProxyPool(poolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all proxy pools
         * @summary List proxy pools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProxyPools(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProxyPool>> {
            return localVarFp.listProxyPools(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a proxy from a pool
         * @summary Remove proxy from pool
         * @param {string} poolId Pool ID
         * @param {string} proxyId Proxy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProxyFromPool(poolId: string, proxyId: string, options?: RawAxiosRequestConfig): AxiosPromise<RemoveProxyFromPool200Response> {
            return localVarFp.removeProxyFromPool(poolId, proxyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a proxy pool by ID
         * @summary Update proxy pool
         * @param {string} poolId Pool ID
         * @param {ProxyPoolRequest} proxyPoolRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProxyPool(poolId: string, proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProxyPool> {
            return localVarFp.updateProxyPool(poolId, proxyPoolRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxyPoolsApi - object-oriented interface
 * @export
 * @class ProxyPoolsApi
 * @extends {BaseAPI}
 */
export class ProxyPoolsApi extends BaseAPI {
    /**
     * Assigns a proxy to a pool
     * @summary Add proxy to pool
     * @param {string} poolId Pool ID
     * @param {AddProxyToPoolRequest} addProxyToPoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public addProxyToPool(poolId: string, addProxyToPoolRequest: AddProxyToPoolRequest, options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).addProxyToPool(poolId, addProxyToPoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new proxy pool
     * @summary Create proxy pool
     * @param {ProxyPoolRequest} proxyPoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public createProxyPool(proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).createProxyPool(proxyPoolRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a proxy pool by ID
     * @summary Delete proxy pool
     * @param {string} poolId Pool ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public deleteProxyPool(poolId: string, options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).deleteProxyPool(poolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all proxy pools
     * @summary List proxy pools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public listProxyPools(options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).listProxyPools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a proxy from a pool
     * @summary Remove proxy from pool
     * @param {string} poolId Pool ID
     * @param {string} proxyId Proxy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public removeProxyFromPool(poolId: string, proxyId: string, options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).removeProxyFromPool(poolId, proxyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a proxy pool by ID
     * @summary Update proxy pool
     * @param {string} poolId Pool ID
     * @param {ProxyPoolRequest} proxyPoolRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyPoolsApi
     */
    public updateProxyPool(poolId: string, proxyPoolRequest: ProxyPoolRequest, options?: RawAxiosRequestConfig) {
        return ProxyPoolsApiFp(this.configuration).updateProxyPool(poolId, proxyPoolRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
export const UtilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Simple ping endpoint to test server connectivity
         * @summary Basic connectivity test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesApi - functional programming interface
 * @export
 */
export const UtilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Simple ping endpoint to test server connectivity
         * @summary Basic connectivity test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UtilitiesApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UtilitiesApi - factory interface
 * @export
 */
export const UtilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesApiFp(configuration)
    return {
        /**
         * Simple ping endpoint to test server connectivity
         * @summary Basic connectivity test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: RawAxiosRequestConfig): AxiosPromise<Ping200Response> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
export class UtilitiesApi extends BaseAPI {
    /**
     * Simple ping endpoint to test server connectivity
     * @summary Basic connectivity test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebSocketApi - axios parameter creator
 * @export
 */
export const WebSocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upgrades HTTP connection to WebSocket for real-time communication
         * @summary WebSocket connection endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectWebSocket: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/ws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebSocketApi - functional programming interface
 * @export
 */
export const WebSocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebSocketApiAxiosParamCreator(configuration)
    return {
        /**
         * Upgrades HTTP connection to WebSocket for real-time communication
         * @summary WebSocket connection endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectWebSocket(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectWebSocket(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebSocketApi.connectWebSocket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebSocketApi - factory interface
 * @export
 */
export const WebSocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebSocketApiFp(configuration)
    return {
        /**
         * Upgrades HTTP connection to WebSocket for real-time communication
         * @summary WebSocket connection endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectWebSocket(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connectWebSocket(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebSocketApi - object-oriented interface
 * @export
 * @class WebSocketApi
 * @extends {BaseAPI}
 */
export class WebSocketApi extends BaseAPI {
    /**
     * Upgrades HTTP connection to WebSocket for real-time communication
     * @summary WebSocket connection endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebSocketApi
     */
    public connectWebSocket(options?: RawAxiosRequestConfig) {
        return WebSocketApiFp(this.configuration).connectWebSocket(options).then((request) => request(this.axios, this.basePath));
    }
}



