/* tslint:disable */
/* eslint-disable */
/**
 * Domain Flow API
 * DomainFlow is a campaign-focused domain intelligence platform. The API manages personas, proxies, keyword pipelines, monitoring, and campaign execution while exposing configuration and scoring surfaces for both UI and automation clients. 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: api@domainflow.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig, AxiosHeaderValue, AxiosHeaders } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { BulkAnalyticsRequest } from '../models';
// @ts-ignore
import type { BulkAnalyticsResponse } from '../models';
// @ts-ignore
import type { BulkDNSValidationRequest } from '../models';
// @ts-ignore
import type { BulkDomainGenerationRequest } from '../models';
// @ts-ignore
import type { BulkGenerationResponse } from '../models';
// @ts-ignore
import type { BulkHTTPValidationRequest } from '../models';
// @ts-ignore
import type { BulkResourceAllocationRequest } from '../models';
// @ts-ignore
import type { BulkResourceAllocationResponse } from '../models';
// @ts-ignore
import type { BulkValidationResponse } from '../models';
// @ts-ignore
import type { CampaignClassificationsResponse } from '../models';
// @ts-ignore
import type { CampaignDomainsListResponse } from '../models';
// @ts-ignore
import type { CampaignFunnelResponse } from '../models';
// @ts-ignore
import type { CampaignMetricsResponse } from '../models';
// @ts-ignore
import type { CampaignModeUpdateResponse } from '../models';
// @ts-ignore
import type { CampaignMomentumResponse } from '../models';
// @ts-ignore
import type { CampaignPhaseEnum } from '../models';
// @ts-ignore
import type { CampaignPhasesStatusResponse } from '../models';
// @ts-ignore
import type { CampaignProgressResponse } from '../models';
// @ts-ignore
import type { CampaignRecommendationsResponse } from '../models';
// @ts-ignore
import type { CampaignResponse } from '../models';
// @ts-ignore
import type { CampaignRestartResponse } from '../models';
// @ts-ignore
import type { CampaignState } from '../models';
// @ts-ignore
import type { CampaignStateUpdate } from '../models';
// @ts-ignore
import type { CampaignStateWithExecutions } from '../models';
// @ts-ignore
import type { CampaignStopResponse } from '../models';
// @ts-ignore
import type { CampaignsBulkOperationsList200ResponseInner } from '../models';
// @ts-ignore
import type { CampaignsModeUpdateRequest } from '../models';
// @ts-ignore
import type { CampaignsPhaseConfigsList200Response } from '../models';
// @ts-ignore
import type { CampaignsPhaseStart409Response } from '../models';
// @ts-ignore
import type { CancelBulkOperation200Response } from '../models';
// @ts-ignore
import type { CreateCampaignRequest } from '../models';
// @ts-ignore
import type { DiscoveryLineageResponse } from '../models';
// @ts-ignore
import type { DiscoveryPreviewRequest } from '../models';
// @ts-ignore
import type { DiscoveryPreviewResponse } from '../models';
// @ts-ignore
import type { DomainScoreBreakdownResponse } from '../models';
// @ts-ignore
import type { EnrichedCampaignResponse } from '../models';
// @ts-ignore
import type { ErrorEnvelope } from '../models';
// @ts-ignore
import type { GetBulkOperationStatus200Response } from '../models';
// @ts-ignore
import type { GetBulkResourceStatus200Response } from '../models';
// @ts-ignore
import type { PatternOffsetRequest } from '../models';
// @ts-ignore
import type { PatternOffsetResponse } from '../models';
// @ts-ignore
import type { PhaseConfigurationRequest } from '../models';
// @ts-ignore
import type { PhaseExecution } from '../models';
// @ts-ignore
import type { PhaseExecutionUpdate } from '../models';
// @ts-ignore
import type { PhaseStatusEnum } from '../models';
// @ts-ignore
import type { PhaseStatusResponse } from '../models';
// @ts-ignore
import type { UpdateCampaignRequest } from '../models';
/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Allocate bulk operation resources
         * @param {BulkResourceAllocationRequest} bulkResourceAllocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocateBulkResources: async (bulkResourceAllocationRequest: BulkResourceAllocationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkResourceAllocationRequest' is not null or undefined
            assertParamExists('allocateBulkResources', 'bulkResourceAllocationRequest', bulkResourceAllocationRequest)
            const localVarPath = `/campaigns/bulk/resources/allocate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(bulkResourceAllocationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk domain analysis
         * @param {BulkAnalyticsRequest} bulkAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkAnalyzeDomains: async (bulkAnalyticsRequest: BulkAnalyticsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkAnalyticsRequest' is not null or undefined
            assertParamExists('bulkAnalyzeDomains', 'bulkAnalyticsRequest', bulkAnalyticsRequest)
            const localVarPath = `/campaigns/bulk/domains/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(bulkAnalyticsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk domain generation
         * @param {BulkDomainGenerationRequest} bulkDomainGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGenerateDomains: async (bulkDomainGenerationRequest: BulkDomainGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDomainGenerationRequest' is not null or undefined
            assertParamExists('bulkGenerateDomains', 'bulkDomainGenerationRequest', bulkDomainGenerationRequest)
            const localVarPath = `/campaigns/bulk/domains/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDomainGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk DNS validation
         * @param {BulkDNSValidationRequest} bulkDNSValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkValidateDNS: async (bulkDNSValidationRequest: BulkDNSValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkDNSValidationRequest' is not null or undefined
            assertParamExists('bulkValidateDNS', 'bulkDNSValidationRequest', bulkDNSValidationRequest)
            const localVarPath = `/campaigns/bulk/domains/validate-dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDNSValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk HTTP validation
         * @param {BulkHTTPValidationRequest} bulkHTTPValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkValidateHTTP: async (bulkHTTPValidationRequest: BulkHTTPValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkHTTPValidationRequest' is not null or undefined
            assertParamExists('bulkValidateHTTP', 'bulkHTTPValidationRequest', bulkHTTPValidationRequest)
            const localVarPath = `/campaigns/bulk/domains/validate-http`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(bulkHTTPValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bulk operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsBulkOperationsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns/bulk/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign classification buckets
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsClassificationsGet: async (campaignId: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsClassificationsGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/classifications`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsCreate: async (createCampaignRequest: CreateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            assertParamExists('campaignsCreate', 'createCampaignRequest', createCampaignRequest)
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(createCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete campaign
         * @summary Delete campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDelete: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsDelete', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the discovery lineage for an existing campaign, including the config hash, offset range used, and other campaigns sharing the same discovery configuration.  This enables: - Understanding which offset range this campaign covers - Comparing yield across campaigns using the same pattern - Analyzing pattern effectiveness over time 
         * @summary Get discovery lineage for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDiscoveryLineage: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsDiscoveryLineage', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/discovery-lineage`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current global pattern offset for domain generation config
         * @param {PatternOffsetRequest} patternOffsetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainGenerationPatternOffset: async (patternOffsetRequest: PatternOffsetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patternOffsetRequest' is not null or undefined
            assertParamExists('campaignsDomainGenerationPatternOffset', 'patternOffsetRequest', patternOffsetRequest)
            const localVarPath = `/campaigns/domain-generation/pattern-offset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(patternOffsetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get detailed score breakdown for a specific domain in a campaign
         * @param {string} campaignId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainScoreBreakdown: async (campaignId: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsDomainScoreBreakdown', 'campaignId', campaignId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('campaignsDomainScoreBreakdown', 'domain', domain)
            const localVarPath = `/campaigns/{campaignId}/domains/{domain}/score-breakdown`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List generated domains for a campaign
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {CampaignsDomainsListDnsStatusEnum} [dnsStatus] Filter domains whose authoritative DNS status matches (pending|ok|error|timeout)
         * @param {CampaignsDomainsListHttpStatusEnum} [httpStatus] Filter domains whose authoritative HTTP status matches (pending|ok|error|timeout)
         * @param {string} [dnsReason] Filter domains by DNS reason (exact match). Example values: NXDOMAIN, SERVFAIL, REFUSED, NOANSWER, TIMEOUT, ERROR
         * @param {string} [httpReason] Filter domains by HTTP reason (exact match). Example values: TIMEOUT, NOT_FOUND, UPSTREAM_5XX, PROXY_ERROR, TLS_ERROR, SSL_EXPIRED, CONNECTION_RESET, ERROR
         * @param {number} [minScore] Minimum inclusive domain score to include
         * @param {boolean} [notParked] Exclude domains detected as parked
         * @param {boolean} [hasContact] Only include domains with detected contact signals
         * @param {string} [keyword] Require at least one keyword match (any)
         * @param {CampaignsDomainsListSortEnum} [sort] Richness-based sort field (defaults to richness_score when omitted)
         * @param {CampaignsDomainsListDirEnum} [dir] Sort direction (defaults to desc)
         * @param {CampaignsDomainsListWarningsEnum} [warnings] Warning filter applied before sorting (has &#x3D; only domains with penalties; none &#x3D; only clean domains)
         * @param {number} [first] Page size for cursor pagination (overrides limit when present)
         * @param {string} [after] Cursor token to continue listing after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainsList: async (campaignId: string, limit?: number, offset?: number, dnsStatus?: CampaignsDomainsListDnsStatusEnum, httpStatus?: CampaignsDomainsListHttpStatusEnum, dnsReason?: string, httpReason?: string, minScore?: number, notParked?: boolean, hasContact?: boolean, keyword?: string, sort?: CampaignsDomainsListSortEnum, dir?: CampaignsDomainsListDirEnum, warnings?: CampaignsDomainsListWarningsEnum, first?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsDomainsList', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/domains`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (dnsStatus !== undefined) {
                localVarQueryParameter['dnsStatus'] = dnsStatus;
            }

            if (httpStatus !== undefined) {
                localVarQueryParameter['httpStatus'] = httpStatus;
            }

            if (dnsReason !== undefined) {
                localVarQueryParameter['dnsReason'] = dnsReason;
            }

            if (httpReason !== undefined) {
                localVarQueryParameter['httpReason'] = httpReason;
            }

            if (minScore !== undefined) {
                localVarQueryParameter['minScore'] = minScore;
            }

            if (notParked !== undefined) {
                localVarQueryParameter['notParked'] = notParked;
            }

            if (hasContact !== undefined) {
                localVarQueryParameter['hasContact'] = hasContact;
            }

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }

            if (warnings !== undefined) {
                localVarQueryParameter['warnings'] = warnings;
            }

            if (first !== undefined) {
                localVarQueryParameter['first'] = first;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDuplicatePost: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsDuplicatePost', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/duplicate`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns campaign with state and recent phase executions as a single enriched read model
         * @summary Get enriched campaign details
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsEnrichedGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsEnrichedGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/enriched`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign funnel snapshot
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsFunnelGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsFunnelGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/funnel`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/campaigns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign KPI & warning metrics
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsMetricsGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsMetricsGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/metrics`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update campaign execution mode
         * @param {string} campaignId 
         * @param {CampaignsModeUpdateRequest} campaignsModeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsModeUpdate: async (campaignId: string, campaignsModeUpdateRequest: CampaignsModeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsModeUpdate', 'campaignId', campaignId)
            // verify required parameter 'campaignsModeUpdateRequest' is not null or undefined
            assertParamExists('campaignsModeUpdate', 'campaignsModeUpdateRequest', campaignsModeUpdateRequest)
            const localVarPath = `/campaigns/{campaignId}/mode`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(campaignsModeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign momentum & movers
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsMomentumGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsMomentumGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/momentum`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List stored phase configurations for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseConfigsList: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseConfigsList', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/configs`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Configure campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseConfigurationRequest} phaseConfigurationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseConfigure: async (campaignId: string, phase: CampaignPhaseEnum, phaseConfigurationRequest: PhaseConfigurationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseConfigure', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhaseConfigure', 'phase', phase)
            // verify required parameter 'phaseConfigurationRequest' is not null or undefined
            assertParamExists('campaignsPhaseConfigure', 'phaseConfigurationRequest', phaseConfigurationRequest)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/configure`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(phaseConfigurationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete phase execution by phase type
         * @summary Delete phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionDeletePhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionDelete: async (campaignId: string, phaseType: CampaignsPhaseExecutionDeletePhaseTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseExecutionDelete', 'campaignId', campaignId)
            // verify required parameter 'phaseType' is not null or undefined
            assertParamExists('campaignsPhaseExecutionDelete', 'phaseType', phaseType)
            const localVarPath = `/campaigns/{campaignId}/phase-executions/{phaseType}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phaseType"}}`, encodeURIComponent(String(phaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionGetPhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionGet: async (campaignId: string, phaseType: CampaignsPhaseExecutionGetPhaseTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseExecutionGet', 'campaignId', campaignId)
            // verify required parameter 'phaseType' is not null or undefined
            assertParamExists('campaignsPhaseExecutionGet', 'phaseType', phaseType)
            const localVarPath = `/campaigns/{campaignId}/phase-executions/{phaseType}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phaseType"}}`, encodeURIComponent(String(phaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionPutPhaseTypeEnum} phaseType 
         * @param {PhaseExecutionUpdate} phaseExecutionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionPut: async (campaignId: string, phaseType: CampaignsPhaseExecutionPutPhaseTypeEnum, phaseExecutionUpdate: PhaseExecutionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseExecutionPut', 'campaignId', campaignId)
            // verify required parameter 'phaseType' is not null or undefined
            assertParamExists('campaignsPhaseExecutionPut', 'phaseType', phaseType)
            // verify required parameter 'phaseExecutionUpdate' is not null or undefined
            assertParamExists('campaignsPhaseExecutionPut', 'phaseExecutionUpdate', phaseExecutionUpdate)
            const localVarPath = `/campaigns/{campaignId}/phase-executions/{phaseType}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phaseType"}}`, encodeURIComponent(String(phaseType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(phaseExecutionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List phase executions for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionsList: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseExecutionsList', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/phase-executions`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually pause an in-progress phase. Discovery (domain generation) executes offline and cannot be paused.  P3.2: Supports expected_state precondition - if provided, pause only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Pause campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, pause only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhasePause: async (campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhasePause', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhasePause', 'phase', phase)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/pause`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required

            if (expectedState !== undefined) {
                localVarQueryParameter['expected_state'] = expectedState;
            }


    
            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resume a previously paused phase and transition it back to in_progress when supported.  P3.2: Supports expected_state precondition - if provided, resume only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Resume campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, resume only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseResume: async (campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseResume', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhaseResume', 'phase', phase)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/resume`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required

            if (expectedState !== undefined) {
                localVarQueryParameter['expected_state'] = expectedState;
            }


    
            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a campaign phase. Validates that prior phases are complete and configs exist.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Start campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStart: async (campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseStart', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhaseStart', 'phase', phase)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/start`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get phase status
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStatus: async (campaignId: string, phase: CampaignPhaseEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseStatus', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhaseStatus', 'phase', phase)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop/cancel a running or paused phase, marking it as failed.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStop: async (campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsPhaseStop', 'campaignId', campaignId)
            // verify required parameter 'phase' is not null or undefined
            assertParamExists('campaignsPhaseStop', 'phase', phase)
            const localVarPath = `/campaigns/{campaignId}/phases/{phase}/stop`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"phase"}}`, encodeURIComponent(String(phase)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign progress
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsProgress: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsProgress', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/progress`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign recommendations
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRecommendationsGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsRecommendationsGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/insights/recommendations`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sequentially restarts DNS validation, HTTP validation, analysis, and enrichment while skipping the discovery phase which runs offline.
         * @summary Restart campaign pipeline (excludes discovery)
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRestart: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsRestart', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/restart`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete campaign state
         * @summary Delete campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStateDelete: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsStateDelete', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/state`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStateGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsStateGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/state`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update campaign state
         * @param {string} campaignId 
         * @param {CampaignStateUpdate} campaignStateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStatePut: async (campaignId: string, campaignStateUpdate: CampaignStateUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsStatePut', 'campaignId', campaignId)
            // verify required parameter 'campaignStateUpdate' is not null or undefined
            assertParamExists('campaignsStatePut', 'campaignStateUpdate', campaignStateUpdate)
            const localVarPath = `/campaigns/{campaignId}/state`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(campaignStateUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get consolidated campaign phase statuses
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStatusGet: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsStatusGet', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/status`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issues a cooperative stop command against whichever phase is active and marks the campaign as cancelled.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop the currently running campaign phase
         * @param {string} campaignId 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStop: async (campaignId: string, xIdempotencyKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsStop', 'campaignId', campaignId)
            const localVarPath = `/campaigns/{campaignId}/stop`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} campaignId 
         * @param {UpdateCampaignRequest} updateCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsUpdate: async (campaignId: string, updateCampaignRequest: UpdateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsUpdate', 'campaignId', campaignId)
            // verify required parameter 'updateCampaignRequest' is not null or undefined
            assertParamExists('campaignsUpdate', 'updateCampaignRequest', updateCampaignRequest)
            const localVarPath = `/campaigns/{campaignId}`
                .replace(`{${"campaignId"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(updateCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel a bulk operation
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBulkOperation: async (operationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('cancelBulkOperation', 'operationId', operationId)
            const localVarPath = `/campaigns/bulk/operations/{operationId}/cancel`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews a discovery configuration before campaign creation. Returns the config hash, next available offset, total combinations, and prior campaigns that share this configuration.  Use this endpoint to understand: - Where generation will start (next_offset) - How many combinations remain for this pattern - Historical yield from campaigns using the same pattern 
         * @summary Preview discovery configuration
         * @param {DiscoveryPreviewRequest} discoveryPreviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoveryPreview: async (discoveryPreviewRequest: DiscoveryPreviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discoveryPreviewRequest' is not null or undefined
            assertParamExists('discoveryPreview', 'discoveryPreviewRequest', discoveryPreviewRequest)
            const localVarPath = `/discovery/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();
            localVarRequestOptions.data = serializeDataIfNeeded(discoveryPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get bulk operation status
         * @param {string} operationId Bulk operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkOperationStatus: async (operationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('getBulkOperationStatus', 'operationId', operationId)
            const localVarPath = `/campaigns/bulk/operations/{operationId}/status`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status of bulk resource allocation
         * @param {string} allocationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkResourceStatus: async (allocationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'allocationId' is not null or undefined
            assertParamExists('getBulkResourceStatus', 'allocationId', allocationId)
            const localVarPath = `/campaigns/bulk/resources/status/{allocationId}`
                .replace(`{${"allocationId"}}`, encodeURIComponent(String(allocationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            const baseOptions: RawAxiosRequestConfig = configuration?.baseOptions ?? {};

            const localVarRequestOptions: RawAxiosRequestConfig = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter: Record<string, AxiosHeaderValue> = {};
            const localVarQueryParameter: Record<string, unknown> = {};

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            const headerParams = globalAxios.AxiosHeaders.from(localVarHeaderParameter);
            if (baseOptions.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(baseOptions.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            
            if (options.headers) {
                headerParams.set(globalAxios.AxiosHeaders.from(options.headers as AxiosHeaders | Record<string, AxiosHeaderValue> | string));
            }
            localVarRequestOptions.headers = headerParams.toJSON();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Allocate bulk operation resources
         * @param {BulkResourceAllocationRequest} bulkResourceAllocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allocateBulkResources(bulkResourceAllocationRequest: BulkResourceAllocationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkResourceAllocationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allocateBulkResources(bulkResourceAllocationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.allocateBulkResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk domain analysis
         * @param {BulkAnalyticsRequest} bulkAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkAnalyzeDomains(bulkAnalyticsRequest: BulkAnalyticsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkAnalyzeDomains(bulkAnalyticsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.bulkAnalyzeDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk domain generation
         * @param {BulkDomainGenerationRequest} bulkDomainGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkGenerateDomains(bulkDomainGenerationRequest: BulkDomainGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkGenerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkGenerateDomains(bulkDomainGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.bulkGenerateDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk DNS validation
         * @param {BulkDNSValidationRequest} bulkDNSValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkValidateDNS(bulkDNSValidationRequest: BulkDNSValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkValidationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkValidateDNS(bulkDNSValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.bulkValidateDNS']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Bulk HTTP validation
         * @param {BulkHTTPValidationRequest} bulkHTTPValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkValidateHTTP(bulkHTTPValidationRequest: BulkHTTPValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkValidationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkValidateHTTP(bulkHTTPValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.bulkValidateHTTP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List bulk operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsBulkOperationsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignsBulkOperationsList200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsBulkOperationsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsBulkOperationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign classification buckets
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsClassificationsGet(campaignId: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignClassificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsClassificationsGet(campaignId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsClassificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsCreate(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsCreate(createCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete campaign
         * @summary Delete campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDelete(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDelete(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the discovery lineage for an existing campaign, including the config hash, offset range used, and other campaigns sharing the same discovery configuration.  This enables: - Understanding which offset range this campaign covers - Comparing yield across campaigns using the same pattern - Analyzing pattern effectiveness over time 
         * @summary Get discovery lineage for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDiscoveryLineage(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscoveryLineageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDiscoveryLineage(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDiscoveryLineage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current global pattern offset for domain generation config
         * @param {PatternOffsetRequest} patternOffsetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PatternOffsetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDomainGenerationPatternOffset(patternOffsetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDomainGenerationPatternOffset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get detailed score breakdown for a specific domain in a campaign
         * @param {string} campaignId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDomainScoreBreakdown(campaignId: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainScoreBreakdownResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDomainScoreBreakdown(campaignId, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDomainScoreBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List generated domains for a campaign
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {CampaignsDomainsListDnsStatusEnum} [dnsStatus] Filter domains whose authoritative DNS status matches (pending|ok|error|timeout)
         * @param {CampaignsDomainsListHttpStatusEnum} [httpStatus] Filter domains whose authoritative HTTP status matches (pending|ok|error|timeout)
         * @param {string} [dnsReason] Filter domains by DNS reason (exact match). Example values: NXDOMAIN, SERVFAIL, REFUSED, NOANSWER, TIMEOUT, ERROR
         * @param {string} [httpReason] Filter domains by HTTP reason (exact match). Example values: TIMEOUT, NOT_FOUND, UPSTREAM_5XX, PROXY_ERROR, TLS_ERROR, SSL_EXPIRED, CONNECTION_RESET, ERROR
         * @param {number} [minScore] Minimum inclusive domain score to include
         * @param {boolean} [notParked] Exclude domains detected as parked
         * @param {boolean} [hasContact] Only include domains with detected contact signals
         * @param {string} [keyword] Require at least one keyword match (any)
         * @param {CampaignsDomainsListSortEnum} [sort] Richness-based sort field (defaults to richness_score when omitted)
         * @param {CampaignsDomainsListDirEnum} [dir] Sort direction (defaults to desc)
         * @param {CampaignsDomainsListWarningsEnum} [warnings] Warning filter applied before sorting (has &#x3D; only domains with penalties; none &#x3D; only clean domains)
         * @param {number} [first] Page size for cursor pagination (overrides limit when present)
         * @param {string} [after] Cursor token to continue listing after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDomainsList(campaignId: string, limit?: number, offset?: number, dnsStatus?: CampaignsDomainsListDnsStatusEnum, httpStatus?: CampaignsDomainsListHttpStatusEnum, dnsReason?: string, httpReason?: string, minScore?: number, notParked?: boolean, hasContact?: boolean, keyword?: string, sort?: CampaignsDomainsListSortEnum, dir?: CampaignsDomainsListDirEnum, warnings?: CampaignsDomainsListWarningsEnum, first?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignDomainsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDomainsList(campaignId, limit, offset, dnsStatus, httpStatus, dnsReason, httpReason, minScore, notParked, hasContact, keyword, sort, dir, warnings, first, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDomainsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Duplicate campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsDuplicatePost(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsDuplicatePost(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsDuplicatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns campaign with state and recent phase executions as a single enriched read model
         * @summary Get enriched campaign details
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsEnrichedGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnrichedCampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsEnrichedGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsEnrichedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign funnel snapshot
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsFunnelGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignFunnelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsFunnelGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsFunnelGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign KPI & warning metrics
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsMetricsGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsMetricsGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update campaign execution mode
         * @param {string} campaignId 
         * @param {CampaignsModeUpdateRequest} campaignsModeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsModeUpdate(campaignId: string, campaignsModeUpdateRequest: CampaignsModeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignModeUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsModeUpdate(campaignId, campaignsModeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsModeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign momentum & movers
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsMomentumGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignMomentumResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsMomentumGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsMomentumGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List stored phase configurations for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseConfigsList(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignsPhaseConfigsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseConfigsList(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseConfigsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Configure campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseConfigurationRequest} phaseConfigurationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseConfigure(campaignId: string, phase: CampaignPhaseEnum, phaseConfigurationRequest: PhaseConfigurationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseConfigure(campaignId, phase, phaseConfigurationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseConfigure']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete phase execution by phase type
         * @summary Delete phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionDeletePhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseExecutionDelete(campaignId: string, phaseType: CampaignsPhaseExecutionDeletePhaseTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseExecutionDelete(campaignId, phaseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseExecutionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionGetPhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseExecutionGet(campaignId: string, phaseType: CampaignsPhaseExecutionGetPhaseTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseExecutionGet(campaignId, phaseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseExecutionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionPutPhaseTypeEnum} phaseType 
         * @param {PhaseExecutionUpdate} phaseExecutionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseExecutionPut(campaignId: string, phaseType: CampaignsPhaseExecutionPutPhaseTypeEnum, phaseExecutionUpdate: PhaseExecutionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseExecutionPut(campaignId, phaseType, phaseExecutionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseExecutionPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List phase executions for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseExecutionsList(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignStateWithExecutions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseExecutionsList(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseExecutionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually pause an in-progress phase. Discovery (domain generation) executes offline and cannot be paused.  P3.2: Supports expected_state precondition - if provided, pause only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Pause campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, pause only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhasePause(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhasePause(campaignId, phase, expectedState, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhasePause']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resume a previously paused phase and transition it back to in_progress when supported.  P3.2: Supports expected_state precondition - if provided, resume only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Resume campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, resume only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseResume(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseResume(campaignId, phase, expectedState, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseResume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a campaign phase. Validates that prior phases are complete and configs exist.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Start campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseStart(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseStart(campaignId, phase, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get phase status
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseStatus(campaignId: string, phase: CampaignPhaseEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseStatus(campaignId, phase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop/cancel a running or paused phase, marking it as failed.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsPhaseStop(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhaseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsPhaseStop(campaignId, phase, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsPhaseStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign progress
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsProgress(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsProgress(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign recommendations
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsRecommendationsGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRecommendationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsRecommendationsGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsRecommendationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sequentially restarts DNS validation, HTTP validation, analysis, and enrichment while skipping the discovery phase which runs offline.
         * @summary Restart campaign pipeline (excludes discovery)
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsRestart(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRestartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsRestart(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsRestart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete campaign state
         * @summary Delete campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsStateDelete(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsStateDelete(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsStateDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsStateGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsStateGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsStateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update campaign state
         * @param {string} campaignId 
         * @param {CampaignStateUpdate} campaignStateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsStatePut(campaignId: string, campaignStateUpdate: CampaignStateUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsStatePut(campaignId, campaignStateUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsStatePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get consolidated campaign phase statuses
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsStatusGet(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignPhasesStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsStatusGet(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Issues a cooperative stop command against whichever phase is active and marks the campaign as cancelled.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop the currently running campaign phase
         * @param {string} campaignId 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsStop(campaignId: string, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignStopResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsStop(campaignId, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} campaignId 
         * @param {UpdateCampaignRequest} updateCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsUpdate(campaignId: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsUpdate(campaignId, updateCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel a bulk operation
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelBulkOperation(operationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelBulkOperation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBulkOperation(operationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.cancelBulkOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Previews a discovery configuration before campaign creation. Returns the config hash, next available offset, total combinations, and prior campaigns that share this configuration.  Use this endpoint to understand: - Where generation will start (next_offset) - How many combinations remain for this pattern - Historical yield from campaigns using the same pattern 
         * @summary Preview discovery configuration
         * @param {DiscoveryPreviewRequest} discoveryPreviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoveryPreview(discoveryPreviewRequest: DiscoveryPreviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscoveryPreviewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoveryPreview(discoveryPreviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.discoveryPreview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get bulk operation status
         * @param {string} operationId Bulk operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkOperationStatus(operationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBulkOperationStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkOperationStatus(operationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getBulkOperationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status of bulk resource allocation
         * @param {string} allocationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkResourceStatus(allocationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBulkResourceStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkResourceStatus(allocationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getBulkResourceStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * 
         * @summary Allocate bulk operation resources
         * @param {BulkResourceAllocationRequest} bulkResourceAllocationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allocateBulkResources(bulkResourceAllocationRequest: BulkResourceAllocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkResourceAllocationResponse> {
            return localVarFp.allocateBulkResources(bulkResourceAllocationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk domain analysis
         * @param {BulkAnalyticsRequest} bulkAnalyticsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkAnalyzeDomains(bulkAnalyticsRequest: BulkAnalyticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkAnalyticsResponse> {
            return localVarFp.bulkAnalyzeDomains(bulkAnalyticsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk domain generation
         * @param {BulkDomainGenerationRequest} bulkDomainGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkGenerateDomains(bulkDomainGenerationRequest: BulkDomainGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkGenerationResponse> {
            return localVarFp.bulkGenerateDomains(bulkDomainGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk DNS validation
         * @param {BulkDNSValidationRequest} bulkDNSValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkValidateDNS(bulkDNSValidationRequest: BulkDNSValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkValidationResponse> {
            return localVarFp.bulkValidateDNS(bulkDNSValidationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Bulk HTTP validation
         * @param {BulkHTTPValidationRequest} bulkHTTPValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkValidateHTTP(bulkHTTPValidationRequest: BulkHTTPValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkValidationResponse> {
            return localVarFp.bulkValidateHTTP(bulkHTTPValidationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List bulk operations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsBulkOperationsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignsBulkOperationsList200ResponseInner>> {
            return localVarFp.campaignsBulkOperationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign classification buckets
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsClassificationsGet(campaignId: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CampaignClassificationsResponse> {
            return localVarFp.campaignsClassificationsGet(campaignId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsCreate(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse> {
            return localVarFp.campaignsCreate(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete campaign
         * @summary Delete campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDelete(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignsDelete(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the discovery lineage for an existing campaign, including the config hash, offset range used, and other campaigns sharing the same discovery configuration.  This enables: - Understanding which offset range this campaign covers - Comparing yield across campaigns using the same pattern - Analyzing pattern effectiveness over time 
         * @summary Get discovery lineage for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDiscoveryLineage(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<DiscoveryLineageResponse> {
            return localVarFp.campaignsDiscoveryLineage(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current global pattern offset for domain generation config
         * @param {PatternOffsetRequest} patternOffsetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PatternOffsetResponse> {
            return localVarFp.campaignsDomainGenerationPatternOffset(patternOffsetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get detailed score breakdown for a specific domain in a campaign
         * @param {string} campaignId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainScoreBreakdown(campaignId: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainScoreBreakdownResponse> {
            return localVarFp.campaignsDomainScoreBreakdown(campaignId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List generated domains for a campaign
         * @param {string} campaignId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {CampaignsDomainsListDnsStatusEnum} [dnsStatus] Filter domains whose authoritative DNS status matches (pending|ok|error|timeout)
         * @param {CampaignsDomainsListHttpStatusEnum} [httpStatus] Filter domains whose authoritative HTTP status matches (pending|ok|error|timeout)
         * @param {string} [dnsReason] Filter domains by DNS reason (exact match). Example values: NXDOMAIN, SERVFAIL, REFUSED, NOANSWER, TIMEOUT, ERROR
         * @param {string} [httpReason] Filter domains by HTTP reason (exact match). Example values: TIMEOUT, NOT_FOUND, UPSTREAM_5XX, PROXY_ERROR, TLS_ERROR, SSL_EXPIRED, CONNECTION_RESET, ERROR
         * @param {number} [minScore] Minimum inclusive domain score to include
         * @param {boolean} [notParked] Exclude domains detected as parked
         * @param {boolean} [hasContact] Only include domains with detected contact signals
         * @param {string} [keyword] Require at least one keyword match (any)
         * @param {CampaignsDomainsListSortEnum} [sort] Richness-based sort field (defaults to richness_score when omitted)
         * @param {CampaignsDomainsListDirEnum} [dir] Sort direction (defaults to desc)
         * @param {CampaignsDomainsListWarningsEnum} [warnings] Warning filter applied before sorting (has &#x3D; only domains with penalties; none &#x3D; only clean domains)
         * @param {number} [first] Page size for cursor pagination (overrides limit when present)
         * @param {string} [after] Cursor token to continue listing after
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDomainsList(campaignId: string, limit?: number, offset?: number, dnsStatus?: CampaignsDomainsListDnsStatusEnum, httpStatus?: CampaignsDomainsListHttpStatusEnum, dnsReason?: string, httpReason?: string, minScore?: number, notParked?: boolean, hasContact?: boolean, keyword?: string, sort?: CampaignsDomainsListSortEnum, dir?: CampaignsDomainsListDirEnum, warnings?: CampaignsDomainsListWarningsEnum, first?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignDomainsListResponse> {
            return localVarFp.campaignsDomainsList(campaignId, limit, offset, dnsStatus, httpStatus, dnsReason, httpReason, minScore, notParked, hasContact, keyword, sort, dir, warnings, first, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Duplicate campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsDuplicatePost(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse> {
            return localVarFp.campaignsDuplicatePost(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns campaign with state and recent phase executions as a single enriched read model
         * @summary Get enriched campaign details
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsEnrichedGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnrichedCampaignResponse> {
            return localVarFp.campaignsEnrichedGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign funnel snapshot
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsFunnelGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignFunnelResponse> {
            return localVarFp.campaignsFunnelGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse> {
            return localVarFp.campaignsGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignResponse>> {
            return localVarFp.campaignsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign KPI & warning metrics
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsMetricsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignMetricsResponse> {
            return localVarFp.campaignsMetricsGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update campaign execution mode
         * @param {string} campaignId 
         * @param {CampaignsModeUpdateRequest} campaignsModeUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsModeUpdate(campaignId: string, campaignsModeUpdateRequest: CampaignsModeUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignModeUpdateResponse> {
            return localVarFp.campaignsModeUpdate(campaignId, campaignsModeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign momentum & movers
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsMomentumGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignMomentumResponse> {
            return localVarFp.campaignsMomentumGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List stored phase configurations for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseConfigsList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignsPhaseConfigsList200Response> {
            return localVarFp.campaignsPhaseConfigsList(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Configure campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseConfigurationRequest} phaseConfigurationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseConfigure(campaignId: string, phase: CampaignPhaseEnum, phaseConfigurationRequest: PhaseConfigurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhaseConfigure(campaignId, phase, phaseConfigurationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete phase execution by phase type
         * @summary Delete phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionDeletePhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionDelete(campaignId: string, phaseType: CampaignsPhaseExecutionDeletePhaseTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignsPhaseExecutionDelete(campaignId, phaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionGetPhaseTypeEnum} phaseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionGet(campaignId: string, phaseType: CampaignsPhaseExecutionGetPhaseTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<PhaseExecution> {
            return localVarFp.campaignsPhaseExecutionGet(campaignId, phaseType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update phase execution by phase type
         * @param {string} campaignId 
         * @param {CampaignsPhaseExecutionPutPhaseTypeEnum} phaseType 
         * @param {PhaseExecutionUpdate} phaseExecutionUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionPut(campaignId: string, phaseType: CampaignsPhaseExecutionPutPhaseTypeEnum, phaseExecutionUpdate: PhaseExecutionUpdate, options?: RawAxiosRequestConfig): AxiosPromise<PhaseExecution> {
            return localVarFp.campaignsPhaseExecutionPut(campaignId, phaseType, phaseExecutionUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List phase executions for a campaign
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseExecutionsList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignStateWithExecutions> {
            return localVarFp.campaignsPhaseExecutionsList(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually pause an in-progress phase. Discovery (domain generation) executes offline and cannot be paused.  P3.2: Supports expected_state precondition - if provided, pause only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Pause campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, pause only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhasePause(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhasePause(campaignId, phase, expectedState, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Resume a previously paused phase and transition it back to in_progress when supported.  P3.2: Supports expected_state precondition - if provided, resume only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Resume campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, resume only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseResume(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhaseResume(campaignId, phase, expectedState, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a campaign phase. Validates that prior phases are complete and configs exist.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Start campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStart(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhaseStart(campaignId, phase, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get phase status
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStatus(campaignId: string, phase: CampaignPhaseEnum, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhaseStatus(campaignId, phase, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop/cancel a running or paused phase, marking it as failed.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop campaign phase
         * @param {string} campaignId 
         * @param {CampaignPhaseEnum} phase 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsPhaseStop(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse> {
            return localVarFp.campaignsPhaseStop(campaignId, phase, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign progress
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsProgress(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignProgressResponse> {
            return localVarFp.campaignsProgress(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign recommendations
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRecommendationsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRecommendationsResponse> {
            return localVarFp.campaignsRecommendationsGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sequentially restarts DNS validation, HTTP validation, analysis, and enrichment while skipping the discovery phase which runs offline.
         * @summary Restart campaign pipeline (excludes discovery)
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsRestart(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRestartResponse> {
            return localVarFp.campaignsRestart(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete campaign state
         * @summary Delete campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStateDelete(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignsStateDelete(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get campaign state
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStateGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignState> {
            return localVarFp.campaignsStateGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update campaign state
         * @param {string} campaignId 
         * @param {CampaignStateUpdate} campaignStateUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStatePut(campaignId: string, campaignStateUpdate: CampaignStateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CampaignState> {
            return localVarFp.campaignsStatePut(campaignId, campaignStateUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get consolidated campaign phase statuses
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStatusGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignPhasesStatusResponse> {
            return localVarFp.campaignsStatusGet(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Issues a cooperative stop command against whichever phase is active and marks the campaign as cancelled.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
         * @summary Stop the currently running campaign phase
         * @param {string} campaignId 
         * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsStop(campaignId: string, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignStopResponse> {
            return localVarFp.campaignsStop(campaignId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update campaign
         * @param {string} campaignId 
         * @param {UpdateCampaignRequest} updateCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsUpdate(campaignId: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse> {
            return localVarFp.campaignsUpdate(campaignId, updateCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel a bulk operation
         * @param {string} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBulkOperation(operationId: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelBulkOperation200Response> {
            return localVarFp.cancelBulkOperation(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Previews a discovery configuration before campaign creation. Returns the config hash, next available offset, total combinations, and prior campaigns that share this configuration.  Use this endpoint to understand: - Where generation will start (next_offset) - How many combinations remain for this pattern - Historical yield from campaigns using the same pattern 
         * @summary Preview discovery configuration
         * @param {DiscoveryPreviewRequest} discoveryPreviewRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoveryPreview(discoveryPreviewRequest: DiscoveryPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscoveryPreviewResponse> {
            return localVarFp.discoveryPreview(discoveryPreviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get bulk operation status
         * @param {string} operationId Bulk operation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkOperationStatus(operationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBulkOperationStatus200Response> {
            return localVarFp.getBulkOperationStatus(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status of bulk resource allocation
         * @param {string} allocationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkResourceStatus(allocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBulkResourceStatus200Response> {
            return localVarFp.getBulkResourceStatus(allocationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - interface
 * @export
 * @interface CampaignsApi
 */
export interface CampaignsApiInterface {
    /**
     * 
     * @summary Allocate bulk operation resources
     * @param {BulkResourceAllocationRequest} bulkResourceAllocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    allocateBulkResources(bulkResourceAllocationRequest: BulkResourceAllocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkResourceAllocationResponse>;

    /**
     * 
     * @summary Bulk domain analysis
     * @param {BulkAnalyticsRequest} bulkAnalyticsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    bulkAnalyzeDomains(bulkAnalyticsRequest: BulkAnalyticsRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkAnalyticsResponse>;

    /**
     * 
     * @summary Bulk domain generation
     * @param {BulkDomainGenerationRequest} bulkDomainGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    bulkGenerateDomains(bulkDomainGenerationRequest: BulkDomainGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkGenerationResponse>;

    /**
     * 
     * @summary Bulk DNS validation
     * @param {BulkDNSValidationRequest} bulkDNSValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    bulkValidateDNS(bulkDNSValidationRequest: BulkDNSValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkValidationResponse>;

    /**
     * 
     * @summary Bulk HTTP validation
     * @param {BulkHTTPValidationRequest} bulkHTTPValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    bulkValidateHTTP(bulkHTTPValidationRequest: BulkHTTPValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkValidationResponse>;

    /**
     * 
     * @summary List bulk operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsBulkOperationsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignsBulkOperationsList200ResponseInner>>;

    /**
     * 
     * @summary Get campaign classification buckets
     * @param {string} campaignId 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsClassificationsGet(campaignId: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<CampaignClassificationsResponse>;

    /**
     * 
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsCreate(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse>;

    /**
     * Delete campaign
     * @summary Delete campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDelete(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the discovery lineage for an existing campaign, including the config hash, offset range used, and other campaigns sharing the same discovery configuration.  This enables: - Understanding which offset range this campaign covers - Comparing yield across campaigns using the same pattern - Analyzing pattern effectiveness over time 
     * @summary Get discovery lineage for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDiscoveryLineage(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<DiscoveryLineageResponse>;

    /**
     * 
     * @summary Get current global pattern offset for domain generation config
     * @param {PatternOffsetRequest} patternOffsetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PatternOffsetResponse>;

    /**
     * 
     * @summary Get detailed score breakdown for a specific domain in a campaign
     * @param {string} campaignId 
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDomainScoreBreakdown(campaignId: string, domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainScoreBreakdownResponse>;

    /**
     * 
     * @summary List generated domains for a campaign
     * @param {string} campaignId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {CampaignsDomainsListDnsStatusEnum} [dnsStatus] Filter domains whose authoritative DNS status matches (pending|ok|error|timeout)
     * @param {CampaignsDomainsListHttpStatusEnum} [httpStatus] Filter domains whose authoritative HTTP status matches (pending|ok|error|timeout)
     * @param {string} [dnsReason] Filter domains by DNS reason (exact match). Example values: NXDOMAIN, SERVFAIL, REFUSED, NOANSWER, TIMEOUT, ERROR
     * @param {string} [httpReason] Filter domains by HTTP reason (exact match). Example values: TIMEOUT, NOT_FOUND, UPSTREAM_5XX, PROXY_ERROR, TLS_ERROR, SSL_EXPIRED, CONNECTION_RESET, ERROR
     * @param {number} [minScore] Minimum inclusive domain score to include
     * @param {boolean} [notParked] Exclude domains detected as parked
     * @param {boolean} [hasContact] Only include domains with detected contact signals
     * @param {string} [keyword] Require at least one keyword match (any)
     * @param {CampaignsDomainsListSortEnum} [sort] Richness-based sort field (defaults to richness_score when omitted)
     * @param {CampaignsDomainsListDirEnum} [dir] Sort direction (defaults to desc)
     * @param {CampaignsDomainsListWarningsEnum} [warnings] Warning filter applied before sorting (has &#x3D; only domains with penalties; none &#x3D; only clean domains)
     * @param {number} [first] Page size for cursor pagination (overrides limit when present)
     * @param {string} [after] Cursor token to continue listing after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDomainsList(campaignId: string, limit?: number, offset?: number, dnsStatus?: CampaignsDomainsListDnsStatusEnum, httpStatus?: CampaignsDomainsListHttpStatusEnum, dnsReason?: string, httpReason?: string, minScore?: number, notParked?: boolean, hasContact?: boolean, keyword?: string, sort?: CampaignsDomainsListSortEnum, dir?: CampaignsDomainsListDirEnum, warnings?: CampaignsDomainsListWarningsEnum, first?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignDomainsListResponse>;

    /**
     * 
     * @summary Duplicate campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsDuplicatePost(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse>;

    /**
     * Returns campaign with state and recent phase executions as a single enriched read model
     * @summary Get enriched campaign details
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsEnrichedGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<EnrichedCampaignResponse>;

    /**
     * 
     * @summary Get campaign funnel snapshot
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsFunnelGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignFunnelResponse>;

    /**
     * 
     * @summary Get campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse>;

    /**
     * 
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignResponse>>;

    /**
     * 
     * @summary Get campaign KPI & warning metrics
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsMetricsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignMetricsResponse>;

    /**
     * 
     * @summary Update campaign execution mode
     * @param {string} campaignId 
     * @param {CampaignsModeUpdateRequest} campaignsModeUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsModeUpdate(campaignId: string, campaignsModeUpdateRequest: CampaignsModeUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignModeUpdateResponse>;

    /**
     * 
     * @summary Get campaign momentum & movers
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsMomentumGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignMomentumResponse>;

    /**
     * 
     * @summary List stored phase configurations for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseConfigsList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignsPhaseConfigsList200Response>;

    /**
     * 
     * @summary Configure campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseConfigurationRequest} phaseConfigurationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseConfigure(campaignId: string, phase: CampaignPhaseEnum, phaseConfigurationRequest: PhaseConfigurationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * Delete phase execution by phase type
     * @summary Delete phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionDeletePhaseTypeEnum} phaseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseExecutionDelete(campaignId: string, phaseType: CampaignsPhaseExecutionDeletePhaseTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionGetPhaseTypeEnum} phaseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseExecutionGet(campaignId: string, phaseType: CampaignsPhaseExecutionGetPhaseTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<PhaseExecution>;

    /**
     * 
     * @summary Update phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionPutPhaseTypeEnum} phaseType 
     * @param {PhaseExecutionUpdate} phaseExecutionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseExecutionPut(campaignId: string, phaseType: CampaignsPhaseExecutionPutPhaseTypeEnum, phaseExecutionUpdate: PhaseExecutionUpdate, options?: RawAxiosRequestConfig): AxiosPromise<PhaseExecution>;

    /**
     * 
     * @summary List phase executions for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseExecutionsList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignStateWithExecutions>;

    /**
     * Manually pause an in-progress phase. Discovery (domain generation) executes offline and cannot be paused.  P3.2: Supports expected_state precondition - if provided, pause only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Pause campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, pause only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhasePause(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * Resume a previously paused phase and transition it back to in_progress when supported.  P3.2: Supports expected_state precondition - if provided, resume only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Resume campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, resume only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseResume(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * Start a campaign phase. Validates that prior phases are complete and configs exist.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Start campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseStart(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * 
     * @summary Get phase status
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseStatus(campaignId: string, phase: CampaignPhaseEnum, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * Stop/cancel a running or paused phase, marking it as failed.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Stop campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsPhaseStop(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<PhaseStatusResponse>;

    /**
     * 
     * @summary Get campaign progress
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsProgress(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignProgressResponse>;

    /**
     * 
     * @summary Get campaign recommendations
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsRecommendationsGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRecommendationsResponse>;

    /**
     * Sequentially restarts DNS validation, HTTP validation, analysis, and enrichment while skipping the discovery phase which runs offline.
     * @summary Restart campaign pipeline (excludes discovery)
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsRestart(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRestartResponse>;

    /**
     * Delete campaign state
     * @summary Delete campaign state
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsStateDelete(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get campaign state
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsStateGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignState>;

    /**
     * 
     * @summary Update campaign state
     * @param {string} campaignId 
     * @param {CampaignStateUpdate} campaignStateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsStatePut(campaignId: string, campaignStateUpdate: CampaignStateUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CampaignState>;

    /**
     * 
     * @summary Get consolidated campaign phase statuses
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsStatusGet(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignPhasesStatusResponse>;

    /**
     * Issues a cooperative stop command against whichever phase is active and marks the campaign as cancelled.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Stop the currently running campaign phase
     * @param {string} campaignId 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsStop(campaignId: string, xIdempotencyKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignStopResponse>;

    /**
     * 
     * @summary Update campaign
     * @param {string} campaignId 
     * @param {UpdateCampaignRequest} updateCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    campaignsUpdate(campaignId: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse>;

    /**
     * 
     * @summary Cancel a bulk operation
     * @param {string} operationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    cancelBulkOperation(operationId: string, options?: RawAxiosRequestConfig): AxiosPromise<CancelBulkOperation200Response>;

    /**
     * Previews a discovery configuration before campaign creation. Returns the config hash, next available offset, total combinations, and prior campaigns that share this configuration.  Use this endpoint to understand: - Where generation will start (next_offset) - How many combinations remain for this pattern - Historical yield from campaigns using the same pattern 
     * @summary Preview discovery configuration
     * @param {DiscoveryPreviewRequest} discoveryPreviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    discoveryPreview(discoveryPreviewRequest: DiscoveryPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<DiscoveryPreviewResponse>;

    /**
     * 
     * @summary Get bulk operation status
     * @param {string} operationId Bulk operation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    getBulkOperationStatus(operationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBulkOperationStatus200Response>;

    /**
     * 
     * @summary Get status of bulk resource allocation
     * @param {string} allocationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApiInterface
     */
    getBulkResourceStatus(allocationId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBulkResourceStatus200Response>;

}

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI implements CampaignsApiInterface {
    /**
     * 
     * @summary Allocate bulk operation resources
     * @param {BulkResourceAllocationRequest} bulkResourceAllocationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public allocateBulkResources(bulkResourceAllocationRequest: BulkResourceAllocationRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).allocateBulkResources(bulkResourceAllocationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk domain analysis
     * @param {BulkAnalyticsRequest} bulkAnalyticsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public bulkAnalyzeDomains(bulkAnalyticsRequest: BulkAnalyticsRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).bulkAnalyzeDomains(bulkAnalyticsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk domain generation
     * @param {BulkDomainGenerationRequest} bulkDomainGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public bulkGenerateDomains(bulkDomainGenerationRequest: BulkDomainGenerationRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).bulkGenerateDomains(bulkDomainGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk DNS validation
     * @param {BulkDNSValidationRequest} bulkDNSValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public bulkValidateDNS(bulkDNSValidationRequest: BulkDNSValidationRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).bulkValidateDNS(bulkDNSValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Bulk HTTP validation
     * @param {BulkHTTPValidationRequest} bulkHTTPValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public bulkValidateHTTP(bulkHTTPValidationRequest: BulkHTTPValidationRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).bulkValidateHTTP(bulkHTTPValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List bulk operations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsBulkOperationsList(options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsBulkOperationsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign classification buckets
     * @param {string} campaignId 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsClassificationsGet(campaignId: string, limit?: number, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsClassificationsGet(campaignId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create campaign
     * @param {CreateCampaignRequest} createCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsCreate(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsCreate(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete campaign
     * @summary Delete campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDelete(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDelete(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the discovery lineage for an existing campaign, including the config hash, offset range used, and other campaigns sharing the same discovery configuration.  This enables: - Understanding which offset range this campaign covers - Comparing yield across campaigns using the same pattern - Analyzing pattern effectiveness over time 
     * @summary Get discovery lineage for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDiscoveryLineage(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDiscoveryLineage(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current global pattern offset for domain generation config
     * @param {PatternOffsetRequest} patternOffsetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDomainGenerationPatternOffset(patternOffsetRequest: PatternOffsetRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDomainGenerationPatternOffset(patternOffsetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get detailed score breakdown for a specific domain in a campaign
     * @param {string} campaignId 
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDomainScoreBreakdown(campaignId: string, domain: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDomainScoreBreakdown(campaignId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List generated domains for a campaign
     * @param {string} campaignId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {CampaignsDomainsListDnsStatusEnum} [dnsStatus] Filter domains whose authoritative DNS status matches (pending|ok|error|timeout)
     * @param {CampaignsDomainsListHttpStatusEnum} [httpStatus] Filter domains whose authoritative HTTP status matches (pending|ok|error|timeout)
     * @param {string} [dnsReason] Filter domains by DNS reason (exact match). Example values: NXDOMAIN, SERVFAIL, REFUSED, NOANSWER, TIMEOUT, ERROR
     * @param {string} [httpReason] Filter domains by HTTP reason (exact match). Example values: TIMEOUT, NOT_FOUND, UPSTREAM_5XX, PROXY_ERROR, TLS_ERROR, SSL_EXPIRED, CONNECTION_RESET, ERROR
     * @param {number} [minScore] Minimum inclusive domain score to include
     * @param {boolean} [notParked] Exclude domains detected as parked
     * @param {boolean} [hasContact] Only include domains with detected contact signals
     * @param {string} [keyword] Require at least one keyword match (any)
     * @param {CampaignsDomainsListSortEnum} [sort] Richness-based sort field (defaults to richness_score when omitted)
     * @param {CampaignsDomainsListDirEnum} [dir] Sort direction (defaults to desc)
     * @param {CampaignsDomainsListWarningsEnum} [warnings] Warning filter applied before sorting (has &#x3D; only domains with penalties; none &#x3D; only clean domains)
     * @param {number} [first] Page size for cursor pagination (overrides limit when present)
     * @param {string} [after] Cursor token to continue listing after
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDomainsList(campaignId: string, limit?: number, offset?: number, dnsStatus?: CampaignsDomainsListDnsStatusEnum, httpStatus?: CampaignsDomainsListHttpStatusEnum, dnsReason?: string, httpReason?: string, minScore?: number, notParked?: boolean, hasContact?: boolean, keyword?: string, sort?: CampaignsDomainsListSortEnum, dir?: CampaignsDomainsListDirEnum, warnings?: CampaignsDomainsListWarningsEnum, first?: number, after?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDomainsList(campaignId, limit, offset, dnsStatus, httpStatus, dnsReason, httpReason, minScore, notParked, hasContact, keyword, sort, dir, warnings, first, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Duplicate campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsDuplicatePost(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsDuplicatePost(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns campaign with state and recent phase executions as a single enriched read model
     * @summary Get enriched campaign details
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsEnrichedGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsEnrichedGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign funnel snapshot
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsFunnelGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsFunnelGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsList(options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign KPI & warning metrics
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsMetricsGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsMetricsGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update campaign execution mode
     * @param {string} campaignId 
     * @param {CampaignsModeUpdateRequest} campaignsModeUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsModeUpdate(campaignId: string, campaignsModeUpdateRequest: CampaignsModeUpdateRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsModeUpdate(campaignId, campaignsModeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign momentum & movers
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsMomentumGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsMomentumGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List stored phase configurations for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseConfigsList(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseConfigsList(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Configure campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseConfigurationRequest} phaseConfigurationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseConfigure(campaignId: string, phase: CampaignPhaseEnum, phaseConfigurationRequest: PhaseConfigurationRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseConfigure(campaignId, phase, phaseConfigurationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete phase execution by phase type
     * @summary Delete phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionDeletePhaseTypeEnum} phaseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseExecutionDelete(campaignId: string, phaseType: CampaignsPhaseExecutionDeletePhaseTypeEnum, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseExecutionDelete(campaignId, phaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionGetPhaseTypeEnum} phaseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseExecutionGet(campaignId: string, phaseType: CampaignsPhaseExecutionGetPhaseTypeEnum, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseExecutionGet(campaignId, phaseType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update phase execution by phase type
     * @param {string} campaignId 
     * @param {CampaignsPhaseExecutionPutPhaseTypeEnum} phaseType 
     * @param {PhaseExecutionUpdate} phaseExecutionUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseExecutionPut(campaignId: string, phaseType: CampaignsPhaseExecutionPutPhaseTypeEnum, phaseExecutionUpdate: PhaseExecutionUpdate, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseExecutionPut(campaignId, phaseType, phaseExecutionUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List phase executions for a campaign
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseExecutionsList(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseExecutionsList(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually pause an in-progress phase. Discovery (domain generation) executes offline and cannot be paused.  P3.2: Supports expected_state precondition - if provided, pause only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Pause campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, pause only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhasePause(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhasePause(campaignId, phase, expectedState, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resume a previously paused phase and transition it back to in_progress when supported.  P3.2: Supports expected_state precondition - if provided, resume only proceeds when current state matches. P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Resume campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {PhaseStatusEnum} [expectedState] P3.2: Precondition check. If provided, resume only proceeds when current phase status matches. Returns 409 EXPECTED_STATE_MISMATCH if actual state differs. 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseResume(campaignId: string, phase: CampaignPhaseEnum, expectedState?: PhaseStatusEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseResume(campaignId, phase, expectedState, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a campaign phase. Validates that prior phases are complete and configs exist.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Start campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseStart(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseStart(campaignId, phase, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get phase status
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseStatus(campaignId: string, phase: CampaignPhaseEnum, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseStatus(campaignId, phase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop/cancel a running or paused phase, marking it as failed.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Stop campaign phase
     * @param {string} campaignId 
     * @param {CampaignPhaseEnum} phase 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsPhaseStop(campaignId: string, phase: CampaignPhaseEnum, xIdempotencyKey?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsPhaseStop(campaignId, phase, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign progress
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsProgress(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsProgress(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign recommendations
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsRecommendationsGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsRecommendationsGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sequentially restarts DNS validation, HTTP validation, analysis, and enrichment while skipping the discovery phase which runs offline.
     * @summary Restart campaign pipeline (excludes discovery)
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsRestart(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsRestart(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete campaign state
     * @summary Delete campaign state
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsStateDelete(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsStateDelete(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get campaign state
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsStateGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsStateGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update campaign state
     * @param {string} campaignId 
     * @param {CampaignStateUpdate} campaignStateUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsStatePut(campaignId: string, campaignStateUpdate: CampaignStateUpdate, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsStatePut(campaignId, campaignStateUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get consolidated campaign phase statuses
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsStatusGet(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsStatusGet(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issues a cooperative stop command against whichever phase is active and marks the campaign as cancelled.  P3.3: Supports X-Idempotency-Key header - duplicate requests with same key return cached result. 
     * @summary Stop the currently running campaign phase
     * @param {string} campaignId 
     * @param {string} [xIdempotencyKey] P3.3: Unique key for duplicate request detection. If a request with this key was already processed within 5 minutes, the cached result is returned without emitting a new SSE sequence. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsStop(campaignId: string, xIdempotencyKey?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsStop(campaignId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update campaign
     * @param {string} campaignId 
     * @param {UpdateCampaignRequest} updateCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsUpdate(campaignId: string, updateCampaignRequest: UpdateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsUpdate(campaignId, updateCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel a bulk operation
     * @param {string} operationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public cancelBulkOperation(operationId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).cancelBulkOperation(operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Previews a discovery configuration before campaign creation. Returns the config hash, next available offset, total combinations, and prior campaigns that share this configuration.  Use this endpoint to understand: - Where generation will start (next_offset) - How many combinations remain for this pattern - Historical yield from campaigns using the same pattern 
     * @summary Preview discovery configuration
     * @param {DiscoveryPreviewRequest} discoveryPreviewRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public discoveryPreview(discoveryPreviewRequest: DiscoveryPreviewRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).discoveryPreview(discoveryPreviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get bulk operation status
     * @param {string} operationId Bulk operation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getBulkOperationStatus(operationId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getBulkOperationStatus(operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status of bulk resource allocation
     * @param {string} allocationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getBulkResourceStatus(allocationId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getBulkResourceStatus(allocationId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum CampaignsDomainsListDnsStatusEnum {
    pending = 'pending',
    ok = 'ok',
    error = 'error',
    timeout = 'timeout'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsDomainsListHttpStatusEnum {
    pending = 'pending',
    ok = 'ok',
    error = 'error',
    timeout = 'timeout'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsDomainsListSortEnum {
    richness_score = 'richness_score',
    microcrawl_gain = 'microcrawl_gain',
    keywords_unique = 'keywords_unique'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsDomainsListDirEnum {
    asc = 'asc',
    desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsDomainsListWarningsEnum {
    has = 'has',
    none = 'none'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsPhaseExecutionDeletePhaseTypeEnum {
    discovery = 'discovery',
    validation = 'validation',
    enrichment = 'enrichment',
    extraction = 'extraction',
    analysis = 'analysis'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsPhaseExecutionGetPhaseTypeEnum {
    discovery = 'discovery',
    validation = 'validation',
    enrichment = 'enrichment',
    extraction = 'extraction',
    analysis = 'analysis'
}
/**
  * @export
  * @enum {string}
  */
export enum CampaignsPhaseExecutionPutPhaseTypeEnum {
    discovery = 'discovery',
    validation = 'validation',
    enrichment = 'enrichment',
    extraction = 'extraction',
    analysis = 'analysis'
}
