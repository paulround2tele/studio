# Aggregated component schemas for modular spec bundling
# This file consolidates all schema definitions so components.schemas can $ref here.
ErrorEnvelope:
  type: object
  properties:
    success:
      type: boolean
      description: Always false for error envelopes.
      default: false
      example: false
      readOnly: true
    error:
      $ref: '#/ApiError'
    requestId:
      type: string
  required: [success, error, requestId]
ErrorCode:
  type: string
  description: Stable error code space
  enum:
    - BAD_REQUEST
    - UNAUTHORIZED
    - FORBIDDEN
    - NOT_FOUND
    - CONFLICT
    - VALIDATION_ERROR
    - REQUIRED_FIELD
    - RATE_LIMIT_EXCEEDED
    - REQUEST_TIMEOUT
    - NOT_IMPLEMENTED
    - INTERNAL_SERVER_ERROR
    - DATABASE_ERROR
    - SERVICE_UNAVAILABLE
    - GATEWAY_TIMEOUT
    - CAMPAIGN_IN_PROGRESS
    - QUOTA_EXCEEDED
    - INVALID_STATE
ApiError:
  type: object
  properties:
    code:
      $ref: '#/ErrorCode'
    message:
      type: string
    details:
      type: array
      items:
        type: object
        properties:
          field:
            type: string
            description: JSON pointer or field path
          code:
            $ref: '#/ErrorCode'
          message:
            type: string
          context:
            type: object
            description: Structured error context values constrained to primitive/array/object envelope.
            additionalProperties:
              $ref: '#/FlexibleValue'
        required: [code, message]
    timestamp:
      type: string
      format: date-time
    path:
      type: string
  required: [code, message, timestamp]

# Reusable flexible value (primitive or small structured) allowed in certain config / context maps
FlexiblePrimitive:
  description: Primitive value allowed in flexible configuration maps.
  nullable: true
  oneOf:
    - { type: string }
    - { type: number }
    - { type: integer }
    - { type: boolean }
FlexibleArray:
  description: Array of primitive flexible values.
  type: array
  items:
    $ref: '#/FlexiblePrimitive'
FlexibleObject:
  description: Nested object whose values are flexible primitives (one-level nesting only).
  type: object
  additionalProperties:
    $ref: '#/FlexiblePrimitive'
FlexibleValue:
  description: Union of acceptable flexible configuration / context value shapes.
  nullable: true
  oneOf:
    - $ref: '#/FlexiblePrimitive'
    - $ref: '#/FlexibleArray'
    - $ref: '#/FlexibleObject'

# Direct response schemas (Option B - no envelope for 2xx)
HealthResponse:
  type: object
  properties:
    status:
      type: string
      enum: [ok]
    version:
      type: string
    uptime:
      type: string
    timestamp:
      type: string
      format: date-time
  required: [status]
  
PingResponse:
  type: object
  properties:
    message:
      type: string
      enum: [pong]
    timestamp:
      type: string
      format: date-time
    version:
      type: string
  required: [message]

# --- Scoring Profiles ---
ScoringProfile:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    description: { type: string, nullable: true }
    weights:
      type: object
      additionalProperties: { type: number, format: float }
    version: { type: integer }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
  required: [id, name, weights, version, createdAt, updatedAt]
ScoringProfileListResponse:
  type: object
  description: Paginated list wrapper for scoring profiles
  properties:
    items:
      type: array
      items: { $ref: '#/ScoringProfile' }
    meta:
      type: object
      description: Pagination metadata
      properties:
        limit:
          type: integer
          minimum: 1
        offset:
          type: integer
          minimum: 0
        total:
          type: integer
          minimum: 0
      required: [limit, offset, total]
  required: [items]
CreateScoringProfileRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    weights:
      type: object
      additionalProperties: { type: number, format: float }
    version:
      type: integer
      description: Optional explicit version; defaults to 1 if omitted
  required: [name, weights]
UpdateScoringProfileRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    weights:
      type: object
      additionalProperties: { type: number, format: float }
    version: { type: integer }
AssociateScoringProfileRequest:
  type: object
  properties:
    profileId: { type: string, format: uuid }
  required: [profileId]
RescoreCampaignRequest:
  type: object
  description: Optional body for future rescore parameters (currently unused)

 # --- Campaign centralized state & phase execution ---
CampaignStateEnum:
  type: string
  enum: [draft, running, paused, completed, failed, cancelled, archived]
CampaignModeEnum:
  type: string
  enum: [full_sequence, step_by_step]
CampaignPhaseEnum:
  type: string
  description: Canonical campaign phase identifier
  enum: [discovery, validation, enrichment, extraction, analysis]
CampaignRestartPhaseEnum:
  type: string
  description: Campaign phases eligible for manual restart controls (discovery executes offline and is excluded)
  enum: [validation, extraction, analysis, enrichment]
ExecutionStatusEnum:
  type: string
  enum: [not_started, ready, configured, in_progress, paused, completed, failed]

CampaignState:
  type: object
  properties:
    campaignId: { type: string, format: uuid }
    currentState: { $ref: '#/CampaignStateEnum' }
    mode: { $ref: '#/CampaignModeEnum' }
    configuration:
      type: object
      additionalProperties:
        $ref: '#/FlexibleValue'
    version: { type: integer }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
  required: [campaignId, currentState, mode, version, createdAt, updatedAt]

CampaignStateUpdate:
  type: object
  properties:
    currentState: { $ref: '#/CampaignStateEnum' }
    mode: { $ref: '#/CampaignModeEnum' }
    configuration:
      type: object
      additionalProperties:
        $ref: '#/FlexibleValue'
    version: { type: integer, description: Optional optimistic concurrency version; if provided must match current }

PhaseExecution:
  type: object
  properties:
    id: { type: string, format: uuid }
    campaignId: { type: string, format: uuid }
    phaseType:
      type: string
      description: Phase identifier
      enum: [discovery, validation, enrichment, extraction, analysis]
    status: { $ref: '#/ExecutionStatusEnum' }
    startedAt: { type: string, format: date-time, nullable: true }
    completedAt: { type: string, format: date-time, nullable: true }
    pausedAt: { type: string, format: date-time, nullable: true }
    failedAt: { type: string, format: date-time, nullable: true }
    progressPercentage: { type: number, format: float }
    totalItems: { type: integer, format: int64 }
    processedItems: { type: integer, format: int64 }
    successfulItems: { type: integer, format: int64 }
    failedItems: { type: integer, format: int64 }
    configuration: { type: object, additionalProperties: {}, nullable: true }
    errorDetails: { type: object, additionalProperties: { $ref: '#/FlexibleValue' }, nullable: true }
    metrics: { type: object, additionalProperties: { $ref: '#/FlexibleValue' }, nullable: true }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
  required: [id, campaignId, phaseType, status, createdAt, updatedAt]

PhaseExecutionUpdate:
  type: object
  properties:
    status: { $ref: '#/ExecutionStatusEnum' }
    startedAt: { type: string, format: date-time, nullable: true }
    completedAt: { type: string, format: date-time, nullable: true }
    pausedAt: { type: string, format: date-time, nullable: true }
    failedAt: { type: string, format: date-time, nullable: true }
    progressPercentage: { type: number, format: float }
    totalItems: { type: integer, format: int64 }
    processedItems: { type: integer, format: int64 }
    successfulItems: { type: integer, format: int64 }
    failedItems: { type: integer, format: int64 }
    configuration: { type: object, additionalProperties: {}, nullable: true }
    errorDetails: { type: object, additionalProperties: { $ref: '#/FlexibleValue' }, nullable: true }
    metrics: { type: object, additionalProperties: { $ref: '#/FlexibleValue' }, nullable: true }

# Composite view
CampaignStateWithExecutions:
  type: object
  properties:
    campaignState: { $ref: '#/CampaignState' }
    phaseExecutions:
      type: array
      items: { $ref: '#/PhaseExecution' }
  required: [campaignState, phaseExecutions]

# Enriched composite view for UI read models
EnrichedCampaignResponse:
  type: object
  description: Read-optimized composite model for campaign detail pages
  properties:
    campaign:
      $ref: '#/CampaignResponse'
    state:
      $ref: '#/CampaignState'
    phaseExecutions:
      type: array
      items: { $ref: '#/PhaseExecution' }
  required: [campaign]

# --- Campaign Domains Listing & Pattern Offset Schemas ---
DomainListItem:
  type: object
  properties:
    id: { type: string, format: uuid }
    domain: { type: string }
    offset: { type: integer, format: int64 }
    createdAt: { type: string, format: date-time }
    dnsStatus: { type: string, description: "DNS validation status (authoritative)" }
    httpStatus: { type: string, description: "HTTP validation status (authoritative)" }
    leadStatus: { type: string, description: "Lead extraction status if available" }
    dnsReason: { type: string, nullable: true, description: "Human-readable reason string for current DNS status (e.g., NXDOMAIN, SERVFAIL, TIMEOUT, BAD_RESPONSE)" }
    httpReason: { type: string, nullable: true, description: "Human-readable reason string for current HTTP status (e.g., CONNECT_ERROR, TLS_ERROR, TIMEOUT, NON_200, BODY_MISMATCH)" }
    features:
      $ref: '#/DomainAnalysisFeatures'
  # required list declared above with properties; stray duplicated fields removed

DomainAnalysisFeatures:
  type: object
  description: Canonical nested analysis feature vector for a discovered domain.
  properties:
    keywords:
      type: object
      properties:
        unique_count: { type: integer, nullable: true }
        hits_total: { type: integer, nullable: true }
        weight_sum: { type: number, format: float, nullable: true }
        top3:
          type: array
          items: { type: string }
        signal_distribution:
          type: object
          additionalProperties: { type: number, format: float }
    richness:
      type: object
      properties:
        score: { type: number, format: float, nullable: true }
        version: { type: integer, nullable: true }
        prominence_norm: { type: number, format: float, nullable: true }
        diversity_effective_unique: { type: number, format: float, nullable: true }
        diversity_norm: { type: number, format: float, nullable: true }
        enrichment_norm: { type: number, format: float, nullable: true }
        applied_bonus: { type: number, format: float, nullable: true }
        applied_deductions_total: { type: number, format: float, nullable: true }
        stuffing_penalty: { type: number, format: float, nullable: true }
        repetition_index: { type: number, format: float, nullable: true }
        anchor_share: { type: number, format: float, nullable: true }
    microcrawl:
      type: object
      properties:
        gain_ratio: { type: number, format: float, nullable: true }
CampaignDomainsListResponse:
  type: object
  properties:
    campaignId: { type: string, format: uuid }
    items:
      type: array
      items: { $ref: '#/DomainListItem' }
    total: { type: integer }
    aggregates:
      type: object
      description: Domain status aggregates sourced from counters table (Phase A optimization)
      properties:
        dns:
          type: object
          properties:
            pending: { type: integer }
            ok: { type: integer }
            error: { type: integer }
            timeout: { type: integer }
        http:
          type: object
          properties:
            pending: { type: integer }
            ok: { type: integer }
            error: { type: integer }
            timeout: { type: integer }
        lead:
          type: object
          properties:
            pending: { type: integer }
            match: { type: integer }
            noMatch: { type: integer }
            error: { type: integer }
            timeout: { type: integer }
    pageInfo:
      $ref: '#/ExtendedPageInfo'
  required: [campaignId, items, total]
PageInfo:
  type: object
  description: Cursor-based pagination metadata
  properties:
    startCursor: { type: string, nullable: true }
    endCursor: { type: string, nullable: true }
    hasNextPage: { type: boolean }
    sortBy: { type: string, description: Field used for ordering }
    sortOrder: { type: string, enum: [ASC, DESC] }
    first: { type: integer, description: Requested page size }
  required: [hasNextPage]
DomainScoreBreakdownResponse:
  type: object
  description: Component scores contributing to the final relevance score for a domain.
  properties:
    campaignId: { type: string, format: uuid }
    domain: { type: string }
    components:
      type: object
      description: Raw component scores normalized to 0-1 prior to weighting.
      properties:
        density: { type: number, format: float }
        coverage: { type: number, format: float }
        non_parked: { type: number, format: float }
        content_length: { type: number, format: float }
        title_keyword: { type: number, format: float }
        freshness: { type: number, format: float }
        tf_lite: { type: number, format: float, description: Experimental TF-lite component (0 if disabled) }
      required: [density, coverage, non_parked, content_length, title_keyword, freshness, tf_lite]
    final: { type: number, format: float, description: Weighted final relevance score after penalties }
    weights:
      type: object
      description: Active scoring profile weights used for combination.
      additionalProperties: { type: number, format: float }
    parkedPenaltyFactor:
      type: number
      format: float
      description: Penalty factor applied when domain considered parked with low confidence (<0.9)
  required: [campaignId, domain, components, final]
PatternOffsetRequest:
  type: object
  properties:
    patternType:
      type: string
      enum: [prefix, suffix, both]
    prefixVariableLength:
      type: integer
      minimum: 0
      description: Optional prefix-side variable length when patternType is prefix or both
    suffixVariableLength:
      type: integer
      minimum: 0
      description: Optional suffix-side variable length when patternType is suffix or both
    variableLength:
      type: integer
      minimum: 0
      description: Legacy combined length retained for backwards compatibility (prefix+suffix)
      deprecated: true
    characterSet: { type: string }
    constantString: { type: string }
    tld: { type: string, description: "Single TLD including dot, e.g. .com or without dot" }
  required: [patternType, characterSet]
PatternOffsetResponse:
  type: object
  properties:
    currentOffset: { type: integer, format: int64 }
PersonaType:
  type: string
  enum: [dns, http]
ProxyProtocol:
  type: string
  enum: [http, https, socks5, socks4]
KeywordRuleType:
  type: string
  enum: [string, regex]

# Bulk operation cancel status enum (used by cancel API response)
BulkOperationCancelStatus:
  type: string
  enum: [cancelled, cancelling]

# Personas
PersonaConfigHttp:
  type: object
  description: HTTP persona configuration details
  properties:
    personaType: 
      type: string
      enum: [http]
      default: http
    userAgent: { type: string }
    headers:
      type: object
      additionalProperties: { type: string }
    headerOrder:
      type: array
      items: { type: string }
    tlsClientHello:
      type: object
      properties:
        minVersion: { type: string, enum: [TLS10, TLS11, TLS12, TLS13] }
        maxVersion: { type: string, enum: [TLS10, TLS11, TLS12, TLS13] }
        cipherSuites:
          type: array
          items: { type: string }
        curvePreferences:
          type: array
          items: { type: string }
    http2Settings:
      type: object
      properties:
        enabled: { type: boolean }
    cookieHandling:
      type: object
      properties:
        mode: { type: string, enum: [preserve, ignore, custom] }
    requestTimeoutSeconds: { type: integer, minimum: 0 }
    followRedirects: { type: boolean }
    allowedStatusCodes:
      type: array
      items: { type: integer, minimum: 100, maximum: 599 }
    rateLimitDps: { type: number, format: float, minimum: 0 }
    rateLimitBurst: { type: integer, minimum: 0 }
    notes: { type: string }
  required: [personaType, userAgent]
PersonaConfigDns:
  type: object
  description: DNS persona configuration details
  properties:
    personaType: 
      type: string
      enum: [dns]
      default: dns
    resolvers:
      type: array
      items: { type: string, description: Host:port or URL }
    useSystemResolvers: { type: boolean }
    queryTimeoutSeconds: { type: integer, minimum: 0 }
    maxDomainsPerRequest: { type: integer, minimum: 1 }
    resolverStrategy: { type: string, enum: [round_robin, random, weighted, priority] }
    resolversWeighted:
      type: object
      additionalProperties: { type: integer }
    resolversPreferredOrder:
      type: array
      items: { type: string }
    concurrentQueriesPerDomain: { type: integer, minimum: 1 }
    queryDelayMinMs: { type: integer, minimum: 0 }
    queryDelayMaxMs: { type: integer, minimum: 0 }
    maxConcurrentGoroutines: { type: integer, minimum: 1 }
    rateLimitDps: { type: number, format: float, minimum: 0 }
    rateLimitBurst: { type: integer, minimum: 0 }
  required: [personaType, resolvers, queryTimeoutSeconds, maxDomainsPerRequest, concurrentQueriesPerDomain]
PersonaConfigDetails:
  oneOf:
    - $ref: '#/PersonaConfigHttp'
    - $ref: '#/PersonaConfigDns'
  discriminator:
    propertyName: personaType
    mapping:
      http: '#/PersonaConfigHttp'
      dns: '#/PersonaConfigDns'
CreatePersonaRequest:
  type: object
  properties:
    name: { type: string }
    personaType: { $ref: '#/PersonaType' }
    description: { type: string }
    configDetails:
      $ref: '#/PersonaConfigDetails'
    isEnabled: { type: boolean }
  required: [name, personaType, configDetails]
UpdatePersonaRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    configDetails:
      $ref: '#/PersonaConfigDetails'
    isEnabled: { type: boolean }
PersonaResponse:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    personaType: { $ref: '#/PersonaType' }
    description: { type: string }
    configDetails:
      $ref: '#/PersonaConfigDetails'
    isEnabled: { type: boolean }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
  required: [id, name, personaType, isEnabled, createdAt, updatedAt]
PersonaTestResponse:
  type: object
  properties:
    personaId: { type: string }
    personaType: { type: string }
    personaName: { type: string }
    success: { type: boolean }
    testPassed: { type: boolean }
    message: { type: string }
    testResults: { type: object }
    results: { type: object }
    timestamp: { type: string }
# Proxies
CreateProxyRequestAPI:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    address: { type: string }
    protocol: { $ref: '#/ProxyProtocol' }
    username: { type: string }
    password: { type: string }
    countryCode: { type: string }
    isEnabled: { type: boolean }
    notes: { type: string }
  required: [name, address]
# Note: ProxyDetailsResponse was removed as part of API contract modernization
# All proxy endpoints now use the full Proxy schema for consistency
Proxy:
  type: object
  description: Full proxy resource representation returned by list/detail operations.
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    description: { type: string }
    address: { type: string }
    protocol: { $ref: '#/ProxyProtocol' }
    username: { type: string }
    host: { type: string }
    port: { type: integer }
    isEnabled: { type: boolean }
    isHealthy: { type: boolean }
    lastStatus: { type: string }
    lastCheckedAt: { type: string, format: date-time }
    latencyMs: { type: integer }
    countryCode: { type: string }
    successCount: { type: integer }
    failureCount: { type: integer }
    lastTested: { type: string, format: date-time }
    lastError: { type: string }
    notes: { type: string }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
  required: [id, name, address, isEnabled, isHealthy, createdAt, updatedAt]
ProxyTestResponse:
  type: object
  properties:
    proxyId: { type: string, format: uuid }
    success: { type: boolean }
    statusCode: { type: integer }
    responseTime: { type: integer, format: int64 }
    error: { type: string }
UpdateProxyRequestAPI:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    address: { type: string }
    protocol: { $ref: '#/ProxyProtocol' }
    username: { type: string }
    password: { type: string }
    countryCode: { type: string }
    isEnabled: { type: boolean }
    notes: { type: string }
ProxyHealthCheckResponse:
  type: object
  properties:
    proxyId: { type: string, format: uuid }
    success: { type: boolean }
    status: { type: string }
    responseTime: { type: integer, format: int64 }
    message: { type: string }
    timestamp: { type: string, format: date-time }
BulkHealthCheckResponse:
  type: object
  properties:
    totalProxies: { type: integer }
    healthyProxies: { type: integer }
    failedProxies: { type: integer }
    results:
      type: array
      items: { $ref: '#/ProxyHealthCheckResponse' }
BulkProxyOperationResponse:
  type: object
  properties:
    totalRequested: { type: integer }
    successCount: { type: integer }
    errorCount: { type: integer }
    successfulProxies:
      type: array
      items: { type: string, format: uuid }
    failedProxies:
      type: array
      items:
        type: object
        properties:
          proxyId: { type: string, format: uuid }
          error: { type: string }
    results:
      type: array
      items:
        type: object
        description: Result record for each proxy operation performed
        properties:
          proxyId: { type: string, format: uuid }
          operation: { type: string, description: "Operation performed (enable|disable|delete|update|test)" }
          success: { type: boolean }
          statusCode: { type: integer, description: "HTTP status or synthetic code for the operation" }
          error: { type: string, description: "Error message if success=false", nullable: true }
          message: { type: string, description: "Optional human readable status message", nullable: true }
        required: [proxyId, operation, success]
  required: [totalRequested, successCount, errorCount]
BulkUpdateProxiesRequest:
  type: object
  properties:
    proxyIds:
      type: array
      items: { type: string, format: uuid }
      minItems: 1
    updates: { $ref: '#/UpdateProxyRequestAPI' }
  required: [proxyIds, updates]
BulkDeleteProxiesRequest:
  type: object
  properties:
    proxyIds:
      type: array
      items: { type: string, format: uuid }
      minItems: 1
  required: [proxyIds]
BulkProxyTestResponse:
  type: object
  properties:
    totalRequested: { type: integer }
    successCount: { type: integer }
    errorCount: { type: integer }
    results:
      type: array
      items: { $ref: '#/ProxyTestResponse' }

ProxyStatusResponse:
  type: object
  properties:
    proxyId: { type: string, format: uuid }
    status: { type: string }
    lastChecked: { type: string, format: date-time }
    responseTime: { type: integer, format: int64 }
    isHealthy: { type: boolean }
    proxyDetails: { $ref: '#/Proxy' }

# Proxy pools
ProxyPool:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    poolStrategy: { type: string }
    healthCheckEnabled: { type: boolean }
    healthCheckIntervalSeconds: { type: integer }
    maxRetries: { type: integer }
    timeoutSeconds: { type: integer }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
    proxies:
      type: array
      items: { type: object, additionalProperties: true }
ProxyPoolRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    poolStrategy: { type: string }
    healthCheckEnabled: { type: boolean }
    healthCheckIntervalSeconds: { type: integer }
    maxRetries: { type: integer }
    timeoutSeconds: { type: integer }
  required: [name]

ProxyPoolMembership:
  type: object
  properties:
    poolId: { type: string, format: uuid }
    proxyId: { type: string, format: uuid }
    weight: { type: integer }
    isActive: { type: boolean }
    addedAt: { type: string, format: date-time }

# Keyword sets / rules
KeywordRuleRequest:
  type: object
  properties:
    pattern: { type: string }
    ruleType: { $ref: '#/KeywordRuleType' }
    isCaseSensitive: { type: boolean }
    category: { type: string }
    contextChars: { type: integer }
  required: [pattern, ruleType]
CreateKeywordSetRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    rules:
      type: array
      items: { $ref: '#/KeywordRuleRequest' }
  required: [name]
KeywordRuleDTO:
  type: object
  properties:
    id: { type: string, format: uuid }
    keywordSetId: { type: string, format: uuid }
    pattern: { type: string }
    ruleType: { type: string }
    isCaseSensitive: { type: boolean }
    category: { type: string }
    contextChars: { type: integer }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
KeywordSetResponse:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
    rules:
      type: array
      items: { $ref: '#/KeywordRuleDTO' }
    ruleCount: { type: integer }
  required: [id, name, isEnabled, createdAt, updatedAt, ruleCount]
UpdateKeywordSetRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    rules:
      type: array
      items: { $ref: '#/KeywordRuleRequest' }
KeywordSetWithRulesResponse:
  type: object
  properties:
    id: { type: string, format: uuid }
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    createdAt: { type: string, format: date-time }
    updatedAt: { type: string, format: date-time }
    rules:
      type: array
      items: { $ref: '#/KeywordRuleDTO' }
    ruleCount: { type: integer }
  required: [id, name, isEnabled, createdAt, updatedAt, rules, ruleCount]

# Extraction
BatchKeywordExtractionRequest:
  type: object
  properties:
    items:
      type: array
      items:
        type: object
        properties:
          url: { type: string, format: uri }
          keywordSetId: { type: string, format: uuid }
          httpPersonaId: { type: string, format: uuid }
          dnsPersonaId: { type: string, format: uuid }
        required: [url, keywordSetId]
  required: [items]
BatchKeywordExtractionResponse:
  type: object
  properties:
    results:
      type: array
      items:
        type: object
        properties:
          url: { type: string, format: uri }
          keywordSetIdUsed: { type: string, format: uuid }
          httpPersonaIdUsed: { type: string, format: uuid }
          dnsPersonaIdUsed: { type: string, format: uuid }
          proxyIdUsed: { type: string, format: uuid }
          finalURL: { type: string, format: uri }
          statusCode: { type: integer }
          matches:
            type: array
            items:
              type: object
              properties:
                matchedPattern: { type: string }
                matchedText: { type: string }
                category: { type: string }
                contexts:
                  type: array
                  items: { type: string }
          error: { type: string }

# Database bulk
BulkDatabaseQueryRequest:
  type: object
  properties:
    queries:
      type: array
      items:
        type: object
        properties:
          id: { type: string }
          sql: { type: string }
        required: [id, sql]
    limit: { type: integer }
    timeout: { type: integer }
  required: [queries]
BulkDatabaseQueryResponse:
  type: object
  properties:
    results:
      type: object
      additionalProperties:
        type: object
        properties:
          columns: { type: array, items: { type: string } }
          rows:
            type: array
            items:
              type: array
              items:
                $ref: '#/DatabaseValue'
          rowCount: { type: integer }
          executionTime: { type: integer, format: int64 }
          success: { type: boolean }
          error: { type: string }
    totalCount: { type: integer }
DatabaseValue:
  type: object
  properties:
    stringValue: { type: string }
    intValue: { type: integer, format: int64 }
    floatValue: { type: number }
    boolValue: { type: boolean }
    isNull: { type: boolean }
    rawValue: { type: string }
# Database stats
BulkDatabaseStatsRequest:
  type: object
  properties:
    schemas:
      type: array
      items: { type: string }
    tables:
      type: array
      items: { type: string }
    includeIndexes: { type: boolean }
    includeSize: { type: boolean }
  additionalProperties: false
BulkDatabaseStatsResponse:
  type: object
  properties:
    databaseStats: { $ref: '#/DatabaseStats' }
    schemaStats:
      type: object
      additionalProperties:
        $ref: '#/SchemaStats'
    tableStats:
      type: object
      additionalProperties:
        $ref: '#/TableStats'
    totalCount: { type: integer }
DatabaseStats:
  description: Overall database statistics
  type: object
  properties:
    totalTables: { type: integer }
    totalUsers: { type: integer }
    totalSessions: { type: integer }
    databaseSize: { type: string }
    schemaVersion: { type: string }
    uptime: { type: string }
    version: { type: string }
    isHealthy: { type: boolean }
SchemaStats:
  description: Statistics for a specific database schema
  type: object
  properties:
    name: { type: string }
    tableCount: { type: integer }
    totalRows: { type: integer }
    totalSize: { type: string }
TableStats:
  description: Statistics for a specific table
  type: object
  properties:
    name: { type: string }
    rowCount: { type: integer }
    size: { type: string }
    indexes: { type: array, items: { type: string } }

# --- Extended pagination & generic activity item schemas ---
ExtendedPageInfo:
  description: Augmented pagination metadata combining cursor and numeric pagination when simultaneously available.
  allOf:
    - $ref: '#/PageInfo'
    - type: object
      properties:
        current:
          type: integer
          description: 1-based current page index (numeric pagination fallback)
        total:
          type: integer
          description: Total number of pages when known via numeric pagination
ActivityItem:
  description: Generic activity / timeline record with standardized core fields and optional contextual data map.
  type: object
  properties:
    id:
      type: string
      format: uuid
      description: Unique activity identifier
    timestamp:
      type: string
      format: date-time
      description: Event creation timestamp (UTC)
    actorType:
      type: string
      description: Origin actor classification (e.g. system, user, job)
      enum: [system, user, job]
    actorId:
      type: string
      nullable: true
      description: Identifier of user/job/system component (when applicable)
    category:
      type: string
      description: High-level grouping (e.g. campaign, proxy, scoring, system)
    type:
      type: string
      description: Specific activity event type key
    message:
      type: string
      description: Human-readable summary
    severity:
      type: string
      enum: [info, warning, error]
      description: Severity classification
      default: info
    data:
      type: object
      description: Additional contextual structured values (forward-compatible)
      additionalProperties: { $ref: '#/FlexibleValue' }
  required: [id, timestamp, actorType, category, type, message]
  additionalProperties: false

# --- SSE (Server-Sent Events) campaign event schemas ---
# NOTE: SSE endpoints stream individual JSON payloads preceded by an 'event:' line. The shapes below correspond to
# the JSON data portion only; the event type itself is surfaced out-of-band via the SSE event field.
CampaignSseEventType:
  type: string
  discriminator:
    propertyName: type
  description: Enumerated server-sent campaign event names.
  enum:
    - analysis_reuse_enrichment
    - analysis_failed
    - campaign_progress
    - counters_reconciled
    - domain_generated
    - domain_validated
    - phase_started
    - phase_completed
    - phase_failed

# Additional Phase 2 schemas
CampaignModeUpdateResponse:
  type: object
  description: Response model for campaign mode update operation.
  properties:
    mode: { $ref: '#/CampaignModeEnum' }
    campaignId: { type: string, format: uuid }
    updatedAt: { type: string, format: date-time }
  required: [mode, campaignId, updatedAt]

CreateCampaignConfiguration:
  type: object
  description: Configuration fragment accepted at campaign creation time.
  properties:
    generationStrategy: { type: string, enum: [pattern, list, seed_keywords] }
    pattern: { type: string }
    initialDomains:
      type: array
      items: { type: string }
    seedKeywords:
      type: array
      items: { type: string }
  additionalProperties: false

ProxyConfigurationRequest:
  type: object
  properties:
    poolId: { type: string, format: uuid }
    isEnabled: { type: boolean }
    authMode: { type: string, enum: [none, basic, bearer] }
    maxFailures: { type: integer }
    cooldownSeconds: { type: integer }
  required: [poolId]

ProxyConfigurationResponse:
  allOf:
    - $ref: '#/Proxy'
    - type: object
      properties:
        configurationApplied: { type: boolean }

PersonaUpdateRequest:
  type: object
  properties:
    name: { type: string }
    description: { type: string }
    isEnabled: { type: boolean }
    configDetails: { $ref: '#/PersonaConfigDetails' }
  additionalProperties: false

BulkOperationStatusResponse:
  type: object
  properties:
    operationId: { type: string }
    status: { type: string, enum: [queued, running, completed, failed, cancelled] }
    progress:
      type: object
      properties:
        processed: { type: integer }
        total: { type: integer }
      required: [processed, total]
    startedAt: { type: string, format: date-time, nullable: true }
    completedAt: { type: string, format: date-time, nullable: true }
  required: [operationId, status, progress]
AnalysisReuseEnrichmentEvent:
  type: object
  description: Analysis phase reused existing feature vectors.
  properties:
    featureVectorCount:
      type: integer
      nullable: true
      description: Number of feature vectors reused from prior HTTP phase enrichment.
AnalysisFailedEvent:
  type: object
  description: Analysis phase preflight or execution failed.
  properties:
    error: { type: string }
    errorCode: { type: string, nullable: true }
  required: [error]
PhaseTransitionEvent:
  type: object
  description: Phase lifecycle transition (started or completed).
  properties:
    phase: { type: string }
  required: [phase]
PhaseFailedEvent:
  type: object
  description: Phase failure event.
  properties:
    phase: { type: string }
    error: { type: string }
  required: [phase, error]
CampaignCompletedEvent:
  type: object
  description: Campaign has fully completed successfully.
  properties:
    campaignId: { type: string, format: uuid }
  required: [campaignId]
DomainStatusEvent:
  type: object
  description: Domain generation/validation status update (subset / partial DomainListItem fields may be present).
  properties:
    id: { type: string, format: uuid }
    domain: { type: string }
    dnsStatus: { type: string, nullable: true }
    httpStatus: { type: string, nullable: true }
    leadStatus: { type: string, nullable: true }
    dnsReason: { type: string, nullable: true }
    httpReason: { type: string, nullable: true }
    features:
      $ref: '#/DomainAnalysisFeatures'
CampaignSseEventPayload:
  description: Union of possible JSON payload shapes emitted via campaign SSE stream.
  oneOf:
    - $ref: '#/AnalysisReuseEnrichmentEvent'
    - $ref: '#/AnalysisFailedEvent'
    - $ref: '#/CampaignProgressResponse'
    - $ref: '#/DomainStatusEvent'
    - $ref: '#/PhaseTransitionEvent'
    - $ref: '#/PhaseFailedEvent'
    - $ref: '#/CampaignCompletedEvent'

# Wrapper objects with discriminator for strongly typed generation. At the wire level the server still emits only the payload JSON
# with an SSE 'event:' line; the client adapter can wrap it to conform to these shapes for type-safe handling.
CampaignSseAnalysisReuseEnrichmentEvent:
  type: object
  properties:
    type: { type: string, enum: [analysis_reuse_enrichment] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/AnalysisReuseEnrichmentEvent' }
  required: [type]
CampaignSseAnalysisFailedEvent:
  type: object
  properties:
    type: { type: string, enum: [analysis_failed] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/AnalysisFailedEvent' }
  required: [type, payload]
CampaignSseProgressEvent:
  type: object
  properties:
    type: { type: string, enum: [campaign_progress] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/CampaignProgressResponse' }
  required: [type]
CampaignSseDomainGeneratedEvent:
  type: object
  properties:
    type: { type: string, enum: [domain_generated] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/DomainStatusEvent' }
  required: [type]
CampaignSseDomainValidatedEvent:
  type: object
  properties:
    type: { type: string, enum: [domain_validated] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/DomainStatusEvent' }
  required: [type]
CampaignSsePhaseStartedEvent:
  type: object
  properties:
    type: { type: string, enum: [phase_started] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/PhaseTransitionEvent' }
  required: [type]
CampaignSsePhaseCompletedEvent:
  type: object
  properties:
    type: { type: string, enum: [phase_completed] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/PhaseTransitionEvent' }
  required: [type]
CampaignSsePhaseFailedEvent:
  type: object
  properties:
    type: { type: string, enum: [phase_failed] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/PhaseFailedEvent' }
  required: [type]
CampaignSseCompletedEvent:
  type: object
  properties:
    type: { type: string, enum: [campaign_completed] }
    timestamp: { type: string, format: date-time }
    payload: { $ref: '#/CampaignCompletedEvent' }
  required: [type]
CampaignSseEvent:
  description: Discriminated union of all campaign SSE event wrapper objects.
  oneOf:
    - $ref: '#/CampaignSseAnalysisReuseEnrichmentEvent'
    - $ref: '#/CampaignSseAnalysisFailedEvent'
    - $ref: '#/CampaignSseProgressEvent'
    - $ref: '#/CampaignSseDomainGeneratedEvent'
    - $ref: '#/CampaignSseDomainValidatedEvent'
    - $ref: '#/CampaignSsePhaseStartedEvent'
    - $ref: '#/CampaignSsePhaseCompletedEvent'
    - $ref: '#/CampaignSsePhaseFailedEvent'
    - $ref: '#/CampaignSseCompletedEvent'
  discriminator:
    propertyName: type

# Config schemas
AuthConfig:
  type: object
  description: Authentication configuration
  properties:
    provider:
      type: string
      description: Authentication provider type
      enum: [none, local, oauth2, saml]
      default: none
    enabled:
      type: boolean
      description: Whether authentication is enforced
      default: false
    jwtIssuer:
      type: string
      nullable: true
      description: JWT issuer claim value
    jwtAudience:
      type: string
      nullable: true
      description: JWT audience claim value
    accessTokenTtlSeconds:
      type: integer
      format: int32
      minimum: 60
      maximum: 86400
      description: Access token time-to-live in seconds
      default: 3600
    refreshTokenTtlSeconds:
      type: integer
      format: int32
      minimum: 300
      maximum: 2592000
      description: Refresh token time-to-live in seconds
      default: 1209600
    allowedProviders:
      type: array
      description: Providers enabled system-wide
      items: { type: string }
    passwordPolicy:
      type: object
      description: Password policy configuration
      properties:
        minLength:
          type: integer
          minimum: 6
          maximum: 128
          default: 12
        requireNumbers: { type: boolean, default: true }
        requireSymbols: { type: boolean, default: false }
        requireUppercase: { type: boolean, default: true }
        requireLowercase: { type: boolean, default: true }
      additionalProperties: false
  required: [provider, enabled, accessTokenTtlSeconds, refreshTokenTtlSeconds]
  additionalProperties: false
LoggingConfig:
  type: object
  description: Logging configuration
  properties:
    level:
      type: string
      enum: [debug, info, warn, error]
      description: Minimum log level
      default: info
    format:
      type: string
      enum: [json, text]
      description: Log output format
      default: json
    sampleRate:
      type: number
      minimum: 0
      maximum: 1
      description: Fraction of debug/trace events to keep (if applicable)
      nullable: true
    destinations:
      type: array
      items: { type: string }
      description: Log destinations (e.g. stdout, file)
    enableHttpAccessLog:
      type: boolean
      description: Enable structured HTTP access logging
      default: true
    extras:
      type: object
      description: Forward-compatible logging extensions
      additionalProperties: true
  required: [level, format]
  additionalProperties: false
DNSValidatorConfigJSON:
  type: object
  description: DNS validator configuration
  properties:
    resolvers:
      type: array
      items: { type: string }
      description: Custom DNS resolver endpoints
    timeoutMs: { type: integer, format: int32, nullable: true, description: Query timeout in milliseconds }
    retries: { type: integer, format: int32, nullable: true, description: Number of retry attempts }
  additionalProperties: false
HTTPValidatorConfigJSON:
  type: object
  description: HTTP validator configuration
  properties:
    userAgent: { type: string, nullable: true, description: Custom user agent string }
    followRedirects: { type: boolean, nullable: true, description: Follow HTTP redirects }
    timeoutMs: { type: integer, format: int32, nullable: true, description: Request timeout in milliseconds }
    keywords:
      type: array
      items: { type: string }
      description: Keywords to search for within HTTP responses
  additionalProperties: false
WorkerConfig:
  type: object
  description: Worker configuration
  properties:
    poolSize:
      type: integer
      minimum: 1
      maximum: 1000
      description: Number of worker threads in the pool
    maxJobs:
      type: integer
      minimum: 1
      maximum: 10000
      description: Maximum number of jobs in queue
    jobTimeout:
      type: integer
      minimum: 1
      maximum: 3600
      description: Job execution timeout in seconds
    idleTimeout:
      type: integer
      minimum: 1
      maximum: 300
      description: Worker idle timeout in seconds
      nullable: true
    retryAttempts:
      type: integer
      minimum: 0
      maximum: 10
      description: Number of retry attempts for failed jobs
      nullable: true
    retryDelay:
      type: integer
      minimum: 100
      maximum: 60000
      description: Delay between retries in milliseconds
      nullable: true
    enableMetrics:
      type: boolean
      description: Enable worker performance metrics collection
      default: true
    metricsInterval:
      type: integer
      minimum: 1
      maximum: 3600
      description: Metrics collection interval in seconds
      nullable: true
    priority:
      type: string
      enum: [low, normal, high, critical]
      description: Worker pool priority level
      default: normal
    enableHealthChecks:
      type: boolean
      description: Enable worker health monitoring
      default: true
    healthCheckInterval:
      type: integer
      minimum: 5
      maximum: 300
      description: Health check interval in seconds
      nullable: true
  required: [poolSize, maxJobs, jobTimeout]
  additionalProperties: false
WorkerConfigUpdate:
  type: object
  description: Worker configuration update payload
  properties:
    poolSize:
      type: integer
      minimum: 1
      maximum: 1000
      description: Number of worker threads in the pool
    maxJobs:
      type: integer
      minimum: 1
      maximum: 10000
      description: Maximum number of jobs in queue
    jobTimeout:
      type: integer
      minimum: 1
      maximum: 3600
      description: Job execution timeout in seconds
    idleTimeout:
      type: integer
      minimum: 1
      maximum: 300
      description: Worker idle timeout in seconds
    retryAttempts:
      type: integer
      minimum: 0
      maximum: 10
      description: Number of retry attempts for failed jobs
    retryDelay:
      type: integer
      minimum: 100
      maximum: 60000
      description: Delay between retries in milliseconds
    enableMetrics:
      type: boolean
      description: Enable worker performance metrics collection
    metricsInterval:
      type: integer
      minimum: 1
      maximum: 3600
      description: Metrics collection interval in seconds
    priority:
      type: string
      enum: [low, normal, high, critical]
      description: Worker pool priority level
    enableHealthChecks:
      type: boolean
      description: Enable worker health monitoring
    healthCheckInterval:
      type: integer
      minimum: 5
      maximum: 300
      description: Health check interval in seconds
RateLimiterConfig:
  type: object
  description: Rate limiter configuration
  properties:
    enabled:
      type: boolean
      description: Enable request rate limiting
      default: true
    strategy:
      type: string
      enum: [fixed_window, sliding_window, token_bucket]
      description: Rate limiting algorithm
      default: token_bucket
    windowSeconds:
      type: integer
      minimum: 1
      maximum: 3600
      description: Window size for fixed/sliding strategies
      default: 60
    maxRequests:
      type: integer
      minimum: 1
      maximum: 100000
      description: Maximum requests per window
      default: 1000
    burst:
      type: integer
      minimum: 0
      maximum: 100000
      description: Additional burst capacity
      default: 0
    concurrentLimit:
      type: integer
      minimum: 0
      maximum: 100000
      description: Maximum concurrent in-flight requests
      default: 0
    banDurationSeconds:
      type: integer
      minimum: 0
      maximum: 604800
      description: Temporary ban duration when threshold exceeded
      default: 0
    respectForwardedFor:
      type: boolean
      description: Use X-Forwarded-For for client identity
      default: false
  required: [enabled, strategy, windowSeconds, maxRequests]
  additionalProperties: false
ProxyManagerConfigJSON:
  type: object
  description: Proxy manager configuration
  properties:
    strategy:
      type: string
      enum: [round_robin, random, geo, sticky]
      description: Proxy rotation / selection strategy
      default: round_robin
    rotationIntervalSeconds:
      type: integer
      minimum: 0
      maximum: 86400
      description: Interval between proxy rotations
      default: 0
    poolSize:
      type: integer
      minimum: 0
      maximum: 100000
      description: Maximum size of proxy pool
      nullable: true
    failThreshold:
      type: integer
      minimum: 0
      maximum: 100
      description: Failure threshold before proxy eviction
      nullable: true
    fallbackProxy:
      type: string
      description: Fallback proxy endpoint
      nullable: true
    extras:
      type: object
      description: Additional proxy manager options
      additionalProperties: true
  required: [strategy, rotationIntervalSeconds]
  additionalProperties: false
ServerConfigResponse:
  type: object
  description: Consolidated server configuration response
  properties:
    auth: { $ref: '#/AuthConfig' }
    logging: { $ref: '#/LoggingConfig' }
    rateLimiter: { $ref: '#/RateLimiterConfig' }
    proxyManager: { $ref: '#/ProxyManagerConfigJSON' }
    worker: { $ref: '#/WorkerConfig' }
    version: { type: string }
    buildHash: { type: string }
    extras:
      type: object
      description: Additional server configuration values
      additionalProperties: true
  required: [auth, logging, rateLimiter, proxyManager, worker]
  additionalProperties: false
ServerConfigUpdateRequest:
  type: object
  description: Server configuration update request
  properties:
    auth: { $ref: '#/AuthConfig' }
    logging: { $ref: '#/LoggingConfig' }
    rateLimiter: { $ref: '#/RateLimiterConfig' }
    proxyManager: { $ref: '#/ProxyManagerConfigJSON' }
    worker: { $ref: '#/WorkerConfigUpdate' }
    extras:
      type: object
      description: Additional configuration overrides
      additionalProperties: true
  additionalProperties: false

# Feature flags
FeatureFlags:
  type: object
  description: Feature flags map
  additionalProperties:
    type: boolean

# Auth
LoginRequest:
  type: object
  properties:
    email: { type: string, format: email }
    password: { type: string, format: password }
  required: [email, password]
SessionResponse:
  type: object
  properties:
    user: { $ref: '#/UserPublicResponse' }
    token: { type: string }
    refreshToken: { type: string }
    expiresAt: { type: string, format: date-time }
  required: [user, token, expiresAt]
UserPublicResponse:
  type: object
  properties:
    id: { type: string, format: uuid }
    username: { type: string }
    email: { type: string, format: email }
    isActive: { type: boolean }
  required: [id, username, email, isActive]

# Campaigns
CreateCampaignRequest:
  type: object
  properties:
    name:
      type: string
      description: Campaign name
      minLength: 1
      maxLength: 255
    description:
      type: string
      description: Campaign description
    configuration:
      type: object
      description: Campaign configuration settings
      properties:
        maxDomains:
          type: integer
          minimum: 1
          maximum: 1000000
          description: Maximum number of domains to process
        phases:
          type: object
          description: Phase-specific configuration blocks
          properties:
            discovery:
              type: object
              properties:
                enabled: { type: boolean }
                maxDepth: { type: integer, minimum: 1, maximum: 10 }
            validation:
              type: object
              properties:
                enabled: { type: boolean }
                dnsValidation: { type: boolean }
                httpValidation: { type: boolean }
            extraction:
              type: object
              properties:
                enabled: { type: boolean }
                keywordSetIds:
                  type: array
                  items: { type: string, format: uuid }
            analysis:
              type: object
              properties:
                enabled: { type: boolean }
                generateReports: { type: boolean }
        patternConfig:
          type: object
          description: Domain generation pattern configuration snapshot
          properties:
            type: { type: string, enum: [constant, variable] }
            constant: { type: string, description: Constant pattern string when type=constant }
            prefixVariableLength:
              type: integer
              minimum: 0
              maximum: 64
              description: Desired variable length for the prefix segment when pattern type includes prefix variation
            suffixVariableLength:
              type: integer
              minimum: 0
              maximum: 64
              description: Desired variable length for the suffix segment when pattern type includes suffix variation
            variableLength:
              type: integer
              minimum: 0
              maximum: 64
              description: Legacy combined variable length retained for backwards compatibility
              deprecated: true
            charset: { type: string, description: Character set used for variable generation }
            targetDomains:
              type: array
              items: { type: string }
            tlds:
              type: array
              items: { type: string }
            keywordSetIds:
              type: array
              items: { type: string, format: uuid }
            personaIds:
              type: array
              items: { type: string, format: uuid }
            crawlDepth: { type: integer, minimum: 0, maximum: 5 }
            projectionEstimate:
              type: object
              description: Optional projection estimate payload for UI modeling
              additionalProperties: true
          required: [type]
  required: [name]
UpdateCampaignRequest:
  type: object
  properties:
    name:
      type: string
      minLength: 1
      maxLength: 255
    description:
      type: string
    configuration:
      type: object
      description: Campaign configuration settings (same structure as CreateCampaignRequest)
CampaignResponse:
  type: object
  properties:
    id:
      type: string
      format: uuid
    name:
      type: string
    description:
      type: string
    status:
      type: string
      enum: [draft, running, paused, completed, failed, cancelled]
    configuration:
      type: object
      description: Campaign configuration
    currentPhase:
      type: string
      enum: [discovery, validation, enrichment, extraction, analysis]
      nullable: true
    progress:
      type: object
      properties:
        totalDomains: { type: integer }
        processedDomains: { type: integer }
        successfulDomains: { type: integer }
        failedDomains: { type: integer }
        percentComplete: { type: number, format: float }
    createdAt:
      type: string
      format: date-time
    updatedAt:
      type: string
      format: date-time
    startedAt:
      type: string
      format: date-time
      nullable: true
    completedAt:
      type: string
      format: date-time
      nullable: true
  required: [id, name, status, configuration, progress, createdAt, updatedAt]
PhaseConfigurationRequest:
  type: object
  properties:
    configuration:
      type: object
      description: Phase-specific configuration
      additionalProperties: true
    personaIds:
      type: object
      properties:
        httpPersonaId:
          type: string
          format: uuid
          nullable: true
        dnsPersonaId:
          type: string
          format: uuid
          nullable: true
    proxyPoolId:
      type: string
      format: uuid
      nullable: true
    keywordSetIds:
      type: array
      items:
        type: string
        format: uuid
      description: Keyword sets for extraction phase
  required: [configuration]
PhaseStatusResponse:
  type: object
  properties:
    phase:
      type: string
      enum: [discovery, validation, enrichment, extraction, analysis]
    status:
      type: string
      enum: [not_started, configured, running, paused, completed, failed]
    configuration:
      type: object
      description: Current phase configuration
    runtimeControls:
      $ref: '#/PhaseRuntimeControls'
      description: Supported runtime controls for this phase
    startedAt:
      type: string
      format: date-time
      nullable: true
    completedAt:
      type: string
      format: date-time
      nullable: true
    progress:
      type: object
      properties:
        totalItems: { type: integer }
        processedItems: { type: integer }
        successfulItems: { type: integer }
        failedItems: { type: integer }
        percentComplete: { type: number, format: float }
    errors:
      type: array
      items:
        type: object
        properties:
          message: { type: string }
          timestamp: { type: string, format: date-time }
          code: { type: string }
  required: [phase, status, progress]
PhaseRuntimeControls:
  type: object
  description: Declares which runtime controls are supported for a phase
  properties:
    canPause: { type: boolean }
    canResume: { type: boolean }
    canStop: { type: boolean }
    canRestart: { type: boolean }
  required: [canPause, canResume, canStop, canRestart]
CampaignRestartResponse:
  type: object
  description: Summary of a restart request that replays all non-discovery phases sequentially.
  properties:
    campaignId:
      type: string
      format: uuid
    message:
      type: string
      description: Human-readable status message summarizing the restart attempt.
    phasesRestarted:
      type: array
      description: Ordered list of phases that were successfully re-queued.
      items: { $ref: '#/CampaignRestartPhaseEnum' }
    skippedPhases:
      type: array
      description: Phases intentionally excluded from restart (always discovery today).
      items: { $ref: '#/CampaignPhaseEnum' }
    restartErrors:
      type: array
      description: Optional per-phase error details when some phases could not be restarted.
      items:
        type: object
        properties:
          phase: { $ref: '#/CampaignRestartPhaseEnum' }
          message: { type: string }
        required: [phase, message]
    phaseStatuses:
      type: array
      description: Latest status snapshot for each restartable phase after enqueueing.
      items: { $ref: '#/PhaseStatusResponse' }
  required: [campaignId, phasesRestarted]
CampaignStopResponse:
  type: object
  description: Summary payload returned after stopping the active campaign phase.
  properties:
    campaignId:
      type: string
      format: uuid
    stoppedPhase:
      $ref: '#/CampaignPhaseEnum'
    phaseStatus:
      $ref: '#/PhaseStatusResponse'
    message:
      type: string
      description: Human-readable explanation of the stop outcome.
    timestamp:
      type: string
      format: date-time
  required: [campaignId, stoppedPhase, message, phaseStatus]
CampaignProgressResponse:
  type: object
  properties:
    campaignId:
      type: string
      format: uuid
    overall:
      type: object
      properties:
        status:
          type: string
          enum: [draft, running, paused, completed, failed, cancelled]
        percentComplete: { type: number, format: float }
        totalDomains: { type: integer }
        processedDomains: { type: integer }
        successfulDomains: { type: integer }
        failedDomains: { type: integer }
    phases:
      type: object
      properties:
        discovery:
          $ref: '#/PhaseProgressSummary'
        validation:
          $ref: '#/PhaseProgressSummary'
        enrichment:
          $ref: '#/PhaseProgressSummary'
        extraction:
          $ref: '#/PhaseProgressSummary'
        analysis:
          $ref: '#/PhaseProgressSummary'
    timeline:
      type: array
      description: Chronological list of timeline events for campaign lifecycle
      items:
        $ref: '#/TimelineEvent'
  required: [campaignId, overall, phases, timeline]
PhaseProgressSummary:
  type: object
  properties:
    status:
      type: string
      enum: [not_started, configured, running, paused, completed, failed]
    percentComplete: { type: number, format: float }
    itemsProcessed: { type: integer }
    itemsTotal: { type: integer }
    startedAt: { type: string, format: date-time, nullable: true }
    completedAt: { type: string, format: date-time, nullable: true }
    duration: { type: string, nullable: true, description: "Human readable duration" }
  required: [status, percentComplete, itemsProcessed, itemsTotal]

# --- Unified Campaign UX Refactor Schemas ---
CampaignPhasesStatusResponse:
  type: object
  description: Consolidated phase status list plus overall progress
  properties:
    campaignId: { type: string, format: uuid }
    overallProgressPercentage: { type: number, format: float }
    errorMessage:
      type: string
      nullable: true
      description: Optional campaign-level failure message surfaced when the overall run fails.
    phases:
      type: array
      items:
        type: object
        properties:
          phase: { type: string, enum: [generation, dns, http, analysis, leads] }
          status: { type: string, enum: [not_started, ready, configured, in_progress, paused, completed, failed] }
          progressPercentage: { type: number, format: float }
          startedAt: { type: string, format: date-time, nullable: true }
          completedAt: { type: string, format: date-time, nullable: true }
          failedAt:
            type: string
            format: date-time
            nullable: true
            description: Timestamp captured when the phase marked failed.
          errorMessage:
            type: string
            nullable: true
            description: Backend-supplied error message describing why the phase failed.
          errorDetails:
            type: object
            nullable: true
            additionalProperties: {}
            description: Structured metadata describing why the phase failed (code, message, context, etc.).
        required: [phase, status, progressPercentage]
  required: [campaignId, overallProgressPercentage, phases]

CampaignFunnelResponse:
  type: object
  properties:
    generated: { type: integer }
    dnsValid: { type: integer }
    httpValid: { type: integer }
    keywordHits: { type: integer }
    analyzed: { type: integer }
    highPotential: { type: integer }
    leads: { type: integer }
  required: [generated, dnsValid, httpValid, keywordHits, analyzed, highPotential, leads]

CampaignMetricsResponse:
  type: object
  description: KPI and warning component metrics for a campaign
  properties:
    highPotential: { type: integer }
    leads: { type: integer }
    keywordCoveragePct: { type: number, format: float }
    avgRichness: { type: number, format: float }
    warningRatePct: { type: number, format: float }
    medianGain: { type: number, format: float }
    stuffing: { type: integer }
    repetition: { type: integer }
    anchor: { type: integer }
    totalAnalyzed: { type: integer }
  required: [highPotential, leads, keywordCoveragePct, avgRichness, warningRatePct, medianGain, stuffing, repetition, anchor, totalAnalyzed]

CampaignClassificationBucketSample:
  type: object
  properties:
    bucket: { type: string, enum: [highPotential, emerging, atRisk, leadCandidate, lowValue, other] }
    domains:
      type: array
      items:
        type: object
        properties:
          domain: { type: string }
          richness: { type: number, format: float, nullable: true }
        required: [domain]
  required: [bucket, domains]

CampaignClassificationsResponse:
  type: object
  properties:
    counts:
      type: object
      properties:
        highPotential: { type: integer }
        emerging: { type: integer }
        atRisk: { type: integer }
        leadCandidate: { type: integer }
        lowValue: { type: integer }
        other: { type: integer }
      required: [highPotential, emerging, atRisk, leadCandidate, lowValue, other]
    samples:
      type: array
      items: { $ref: '#/CampaignClassificationBucketSample' }
  required: [counts]

CampaignMomentumResponse:
  type: object
  properties:
    moversUp:
      type: array
      items:
        type: object
        properties:
          domain: { type: string }
          delta: { type: number, format: float }
        required: [domain, delta]
    moversDown:
      type: array
      items:
        type: object
        properties:
          domain: { type: string }
          delta: { type: number, format: float }
        required: [domain, delta]
    histogram:
      type: array
      items: { type: integer }
      minItems: 5
      maxItems: 5
  required: [moversUp, moversDown, histogram]

RecommendationSeverity:
  type: string
  enum: [info, warn, action]

CampaignRecommendation:
  type: object
  properties:
    id: { type: string }
    message: { type: string }
    rationaleCode:
      type: string
      enum: [R_DNS_LOW, R_HTTP_LOW, R_FEW_HIGH_POTENTIAL, R_WARNING_RATE_HIGH, R_NO_LEADS, R_MOMENTUM_LOSS, R_MOMENTUM_SURGE, R_ALL_CLEAR]
    severity: { $ref: '#/RecommendationSeverity' }
  required: [id, message, rationaleCode, severity]

CampaignRecommendationsResponse:
  type: object
  properties:
    recommendations:
      type: array
      items: { $ref: '#/CampaignRecommendation' }
  required: [recommendations]

# Bulk operations
BulkDNSValidationRequest:
  type: object
  properties:
    operations:
      type: array
      items:
        type: object
        properties:
          campaignId:
            type: string
            format: uuid
          personaIds:
            type: array
            items:
              type: string
              format: uuid
          maxDomains:
            type: integer
            minimum: 1
            maximum: 10000
          validationConfig:
            type: object
            properties:
              timeout: { type: integer, minimum: 1000, maximum: 30000 }
              retries: { type: integer, minimum: 0, maximum: 5 }
              recordTypes: { type: array, items: { type: string, enum: [A, AAAA, MX, NS, CNAME] } }
        required: [campaignId, personaIds]
      minItems: 1
      maxItems: 50
    batchSize:
      type: integer
      minimum: 1
      maximum: 1000
      default: 100
    stealth:
      type: object
      properties:
        enabled: { type: boolean, default: true }
        randomizationLevel: { type: string, enum: [low, medium, high, extreme], default: medium }
        delayRange: { type: object, properties: { min: { type: integer }, max: { type: integer } } }
  required: [operations]

BulkHTTPValidationRequest:
  type: object
  properties:
    operations:
      type: array
      items:
        type: object
        properties:
          campaignId:
            type: string
            format: uuid
          personaIds:
            type: array
            items:
              type: string
              format: uuid
          keywords:
            type: array
            items:
              type: string
          maxDomains:
            type: integer
            minimum: 1
            maximum: 10000
          validationConfig:
            type: object
            properties:
              timeout: { type: integer, minimum: 5000, maximum: 60000 }
              followRedirects: { type: boolean, default: true }
              userAgent: { type: string }
              headers: { type: object, additionalProperties: { type: string } }
        required: [campaignId, personaIds, keywords]
      minItems: 1
      maxItems: 50
    batchSize:
      type: integer
      minimum: 1
      maximum: 500
      default: 50
    stealth:
      type: object
      properties:
        enabled: { type: boolean, default: true }
        randomizationLevel: { type: string, enum: [low, medium, high, extreme], default: high }
        delayRange: { type: object, properties: { min: { type: integer }, max: { type: integer } } }
  required: [operations]

# Analytics
BulkAnalyticsRequest:
  type: object
  properties:
    campaignIds:
      type: array
      items:
        type: string
        format: uuid
      minItems: 1
      maxItems: 100
    metrics:
      type: array
      items:
        type: string
        enum: [response_time, content_analysis, lead_score, domain_health, keyword_density]
    granularity:
      type: string
      enum: [hour, day, week, month]
      default: day
    timeRange:
      type: object
      properties:
        startTime: { type: string, format: date-time }
        endTime: { type: string, format: date-time }
        timezone: { type: string, default: UTC }
      required: [startTime, endTime]
    aggregation:
      type: object
      properties:
        groupBy: { type: array, items: { type: string } }
        functions: { type: array, items: { type: string, enum: [sum, avg, min, max, count] } }
  required: [campaignIds, metrics, timeRange]

# Duplicate BulkAnalyticsResponse removed (defined earlier)

BulkDomainGenerationRequest:
  type: object
  properties:
    operations:
      type: array
      items:
        type: object
        properties:
          campaignId:
            type: string
            format: uuid
          config:
            type: object
            properties:
              patternType: { type: string, enum: [prefix, suffix, both] }
              prefixVariableLength:
                type: integer
                minimum: 0
                maximum: 20
                description: Optional prefix-side variable length when patternType is prefix or both
              suffixVariableLength:
                type: integer
                minimum: 0
                maximum: 20
                description: Optional suffix-side variable length when patternType is suffix or both
              variableLength:
                type: integer
                minimum: 0
                maximum: 20
                description: Legacy combined length retained for backwards compatibility
                deprecated: true
              characterSet: { type: string }
              constantString: { type: string }
              tlds: { type: array, items: { type: string } }
              numDomainsToGenerate: { type: integer, minimum: 1, maximum: 1000000 }
              batchSize: { type: integer, minimum: 1, maximum: 10000 }
            required: [patternType, characterSet, constantString, tlds, numDomainsToGenerate]
          maxDomains:
            type: integer
            minimum: 1
            maximum: 1000000
        required: [campaignId, config, maxDomains]
      minItems: 1
      maxItems: 100
    batchSize:
      type: integer
      minimum: 1
      maximum: 10000
      default: 1000
    parallel:
      type: boolean
      default: true
  required: [operations]

BulkValidationResponse:
  type: object
  properties:
    operationId:
      type: string
      format: uuid
    status:
      type: string
      enum: [initiated, pending, running]
    operations:
      type: object
      additionalProperties:
        $ref: '#/ProxyOperationResult'
    totalOperations:
      type: integer
    estimatedDuration:
      type: string
      nullable: true
  required: [operationId, status, operations, totalOperations]

ProxyOperationResult:
  description: Result object for a proxy operation containing a proxyId and optional error or metadata.
  type: object
  properties:
    proxyId: { type: string, format: uuid }
    success: { type: boolean }
    error: { type: string, nullable: true }
    metadata:
      type: object
      nullable: true
      additionalProperties:
        $ref: '#/FlexibleValue'
  required: [proxyId, success]

ProxyPoolProxyRef:
  description: Lightweight proxy reference entry for inclusion inside a pool listing.
  type: object
  properties:
    proxyId: { type: string, format: uuid }
    address: { type: string }
    protocol: { type: string }
    isHealthy: { type: boolean }
    lastChecked: { type: string, format: date-time, nullable: true }
    metadata:
      type: object
      nullable: true
      additionalProperties:
        $ref: '#/FlexibleValue'
  required: [proxyId, address, protocol, isHealthy]

BulkGenerationResponse:
  type: object
  properties:
    operationId:
      type: string
      format: uuid
    status:
      type: string
      enum: [initiated, pending, running]
    operations:
      type: object
      additionalProperties:
        type: object
        properties:
          campaignId: { type: string, format: uuid }
          status: { type: string, enum: [pending, running, completed, failed] }
          domainsGenerated: { type: integer }
          progress: { type: object, properties: { processed: { type: integer }, total: { type: integer } } }
    totalOperations:
      type: integer
    estimatedDuration:
      type: string
      nullable: true
  required: [operationId, status, operations, totalOperations]

BulkAnalyticsResponse:
  type: object
  properties:
    operationId:
      type: string
      format: uuid
    status:
      type: string
      enum: [initiated, pending, running, completed]
    analytics:
      type: object
      properties:
        totalCampaigns: { type: integer }
        totalDomains: { type: integer }
        totalLeads: { type: integer }
        overallSuccessRate: { type: number, format: float }
        topPerformingTLDs:
          type: array
          items:
            type: object
            properties:
              tld: { type: string }
              domains: { type: integer }
              leads: { type: integer }
              successRate: { type: number, format: float }
              rank: { type: integer }
        performanceMetrics:
          type: object
          properties:
            avgResponseTime: { type: number, format: float }
            avgLeadScore: { type: number, format: float }
            conversionRate: { type: number, format: float }
    processedCampaigns:
      type: integer
    estimatedCompletion:
      type: string
      format: date-time
      nullable: true
  required: [operationId, status, processedCampaigns]

BulkResourceAllocationRequest:
  type: object
  properties:
    operationType:
      type: string
      enum: [domain_generation, dns_validation, http_validation, analytics]
    resources:
      type: object
      properties:
        cpu: { type: integer, minimum: 1, maximum: 64, description: "CPU cores" }
        memory: { type: integer, minimum: 1, maximum: 128, description: "Memory in GB" }
        networkBandwidth: { type: integer, minimum: 10, maximum: 10000, description: "Bandwidth in Mbps" }
        storage: { type: integer, minimum: 1, maximum: 1000, description: "Storage in GB" }
    priority:
      type: string
      enum: [low, normal, high, critical]
      default: normal
    duration:
      type: integer
      minimum: 300
      maximum: 86400
      description: Resource allocation duration in seconds
    tags:
      type: object
      additionalProperties: { type: string }
      description: Resource allocation tags for tracking
  required: [operationType, resources, duration]

BulkResourceAllocationResponse:
  type: object
  properties:
    allocationId:
      type: string
      format: uuid
    status:
      type: string
      enum: [allocating, allocated, failed]
    resources:
      type: object
      properties:
        cpu: { type: integer }
        memory: { type: integer }
        networkBandwidth: { type: integer }
        storage: { type: integer }
    allocation:
      type: object
      properties:
        allocatedAt: { type: string, format: date-time }
        expiresAt: { type: string, format: date-time }
        estimatedCost: { type: number, format: float, nullable: true }
    endpoints:
      type: object
      properties:
        monitoring: { type: string, format: uri }
        metrics: { type: string, format: uri }
        control: { type: string, format: uri }
  required: [allocationId, status, resources, allocation]

# -------------------------------------------------------------
# Export related schemas (v5 evolution) - added to remove any[]
# -------------------------------------------------------------

AnomalyRecord:
  type: object
  description: "Detected anomaly record used in export bundles"
  properties:
    id: { type: string }
    timestamp: { type: string, format: date-time }
    type: { type: string }
    severity: { type: string, enum: [low, medium, high, critical] }
    description: { type: string }
    status: { type: string, enum: [open, investigating, mitigated, resolved], nullable: true }
    metrics:
      type: object
      additionalProperties: { type: number }
    tags:
      type: array
      items: { type: string }
  required: [id, timestamp, type, severity]

RootCauseEvidence:
  type: object
  description: "Evidence item supporting a root cause factor"
  properties:
    type: { type: string }
    description: { type: string }
    value:
      oneOf:
        - { type: string }
        - { type: number }
        - { type: boolean }
        - type: object
          properties:
            metric: { type: string }
            value: { type: number }
            baseline: { type: number }
            deviation: { type: number }
          required: [metric, value]
        - type: array
          items: { type: string }
    confidence: { type: number, format: float }
    source: { type: string }
    collectedAt: { type: string, format: date-time }
  required: [type, description]

HealthFabricSnapshot:
  type: object
  description: "Snapshot of campaign 'health fabric' status"
  properties:
    timestamp: { type: string, format: date-time }
    healthScore: { type: number, format: float }
    dimensions:
      type: array
      items:
        type: object
        properties:
          name: { type: string }
          score: { type: number, format: float }
          weight: { type: number, format: float, nullable: true }
        required: [name, score]
    anomaliesDetected: { type: integer, nullable: true }
    riskLevel: { type: string, enum: [low, medium, high, critical], nullable: true }
  required: [timestamp, healthScore]

PerformanceMetricRecord:
  type: object
  description: "Time series performance metric for export"
  properties:
    metricKey: { type: string }
    timestamp: { type: string, format: date-time }
    value: { type: number, format: float }
    window: { type: string, enum: [raw, 1m, 5m, 1h, 1d], nullable: true }
    breakdown:
      type: object
      additionalProperties: { type: number }
  required: [metricKey, timestamp, value]

ForecastPoint:
  type: object
  description: "Forecast point with bounds and optional actual value"
  properties:
    metricKey: { type: string }
    timestamp: { type: string, format: date-time }
    predictedValue: { type: number, format: float }
    lowerBound: { type: number, format: float, nullable: true }
    upperBound: { type: number, format: float, nullable: true }
    actualValue: { type: number, format: float, nullable: true }
  required: [metricKey, timestamp, predictedValue]

TimelineEvent:
  type: object
  description: "Unified campaign timeline event for export and progress tracking"
  properties:
    timestamp: { type: string, format: date-time }
    phase: { type: string, nullable: true }
    type: { type: string }
    description: { type: string, nullable: true }
    status: { type: string, enum: [pending, running, completed, failed], nullable: true }
    progress: { type: number, format: float, nullable: true }
    metadata:
      type: object
      additionalProperties:
        oneOf:
          - { type: string }
          - { type: number }
          - { type: boolean }
          # Represent null via nullable string to maintain permissive shape without using explicit 'null' type unsupported by kin-openapi
          - { type: string, nullable: true }
  required: [timestamp, type]

ForecastProbabilisticPoint:
  type: object
  description: "Forecast data point with optional probabilistic quantiles"
  properties:
    timestamp: { type: string, format: date-time }
    value: { type: number, format: float }
    lower: { type: number, format: float, nullable: true }
    upper: { type: number, format: float, nullable: true }
    p10: { type: number, format: float, nullable: true }
    p50: { type: number, format: float, nullable: true }
    p90: { type: number, format: float, nullable: true }
    confidence: { type: number, format: float, nullable: true }
    metricKey: { type: string, nullable: true }
  required: [timestamp, value]

ProbabilisticForecastResponse:
  type: object
  description: "Forecast response including probabilistic quantile points"
  properties:
    horizon: { type: integer }
    generatedAt: { type: string, format: date-time }
    method: { type: string, enum: [server, client, blended] }
    points:
      type: array
      items: { $ref: '#/ForecastProbabilisticPoint' }
    timingMs: { type: integer, nullable: true }
    error: { type: string, nullable: true }
    modelInfo:
      type: object
      nullable: true
      properties:
        selectedModel: { type: string }
        arbitrationScores:
          type: object
          nullable: true
          properties:
            mae: { type: number, format: float }
            mape: { type: number, format: float }
            confidence: { type: number, format: float }
    qualityMetrics:
      type: object
      nullable: true
      properties:
        mae: { type: number, format: float }
        mape: { type: number, format: float }
        residualVariance: { type: number, format: float }
  required: [horizon, generatedAt, method, points]

