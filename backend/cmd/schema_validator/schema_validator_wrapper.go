package main

import (
	"context"
	"fmt"
	"os"

	"github.com/fntelecomllc/studio/backend/internal/models"
	"github.com/fntelecomllc/studio/backend/internal/schemavalidator"
	"github.com/jmoiron/sqlx"
)

// ModelWrapper wraps the schema validator to handle discrepancies between
// database schema and Go models without modifying the original models.
type ModelWrapper struct {
	db *sqlx.DB
}

// NewModelWrapper creates a new ModelWrapper
func NewModelWrapper(db *sqlx.DB) *ModelWrapper {
	return &ModelWrapper{
		db: db,
	}
}

// ValidateSchema validates the schema and generates a report
func (w *ModelWrapper) ValidateSchema(outputFile string) error {
	ctx := context.Background()

	// Extract database schema
	extractor := schemavalidator.NewSchemaExtractor(w.db)
	dbSchema, err := extractor.ExtractDatabaseSchema(ctx)
	if err != nil {
		return fmt.Errorf("failed to extract database schema: %w", err)
	}

	// Build model map with table name mappings
	modelMap := buildWrappedModelMap()

	// Create reflector
	reflector := schemavalidator.NewModelReflector(modelMap)
	modelSchemas, err := reflector.ExtractModelSchemas()
	if err != nil {
		return fmt.Errorf("failed to extract model schemas: %w", err)
	}

	// Apply table name mappings and create a new map with the correct keys
	// This ensures the comparator can match models to tables correctly
	newModelSchemas := make(map[string]schemavalidator.ModelSchema)
	for modelName, schema := range modelSchemas {
		// Use the model name as the key, not the table name
		newModelSchemas[modelName] = schema

		// Log the mapping for debugging
		if tableName, ok := getTableNameMapping(modelName); ok {
			fmt.Printf("Mapping model %s to table %s\n", modelName, tableName)
		}
	}
	modelSchemas = newModelSchemas

	// Create comparator
	comparator := schemavalidator.NewSchemaComparator(dbSchema, modelSchemas)
	result, err := comparator.CompareSchemas()
	if err != nil {
		return fmt.Errorf("failed to compare schemas: %w", err)
	}

	// Generate report
	report := comparator.GenerateReport(result)
	report = enhanceReport(report)

	// Write report to file
	err = os.WriteFile(outputFile, []byte(report), 0644)
	if err != nil {
		return fmt.Errorf("failed to write report to file: %w", err)
	}

	// Print summary
	w.printSummary(result)

	return nil
}

// getTableNameMapping returns the table name for a given model name
func getTableNameMapping(modelName string) (string, bool) {
	// Define table name mappings
	tableNameMappings := map[string]string{
		"Persona":    "personas",
		"Proxy":      "proxies",
		"KeywordSet": "keyword_sets",
		// KeywordRule is embedded in KeywordSet as a JSONB array, not a separate table
		// "KeywordRule":                    "keyword_rules",
		"Campaign":                       "campaigns",
		"DomainGenerationCampaignParams": "domain_generation_campaign_params",
		"DomainGenerationPhaseConfigState":    "domain_generation_config_states",
		"GeneratedDomain":                "generated_domains",
		"DNSValidationCampaignParams":    "dns_validation_campaign_params",
		"HTTPKeywordCampaignParams":      "http_keyword_campaign_params",
		"AuditLog":                       "audit_logs",
		"CampaignJob":                    "campaign_jobs",
	}

	tableName, ok := tableNameMappings[modelName]
	return tableName, ok
}

// enhanceReport can be used to add additional static information or reformat the report if needed.
// The hardcoded "Nullable Fields Handling" section has been removed as models are now updated
// to use pointer types, making that static table inaccurate.
// The main schema comparison should now correctly identify any true nullability mismatches.
func enhanceReport(report string) string {
	// Example: Add a generic note or re-order sections if necessary.
	// For now, just return the report as is.
	// If specific static sections are needed in the future, they can be added here.

	// The "Type Mismatches" and "Table Name Mappings" sections are still useful
	// and are generated by the comparator's GenerateReport method.
	// We can add them here if they were not part of the base report or if we want to format them differently.
	// For now, assuming the base report from comparator.GenerateReport() is sufficient.

	// If we want to ensure certain sections always appear, even if empty, we could do this:
	// if !strings.Contains(report, "## Type Mismatches") {
	// report += "\n## Type Mismatches\n\nNo specific type mismatches noted by wrapper.\n"
	// }
	// if !strings.Contains(report, "## Table Name Mappings") {
	// report += "\n## Table Name Mappings\n\nNo specific table name mappings noted by wrapper.\n"
	// }

	return report
}

// printSummary prints a summary of the validation results
func (w *ModelWrapper) printSummary(result *schemavalidator.ComparisonResult) {
	fmt.Println("\nSchema Validation Summary:")
	fmt.Println("-------------------------")

	// Missing tables
	if len(result.MissingTables) > 0 {
		fmt.Printf("Missing Tables: %d\n", len(result.MissingTables))
		for _, table := range result.MissingTables {
			fmt.Printf("  - %s\n", table)
		}
	} else {
		fmt.Println("Missing Tables: 0")
	}

	// Missing models
	if len(result.MissingModels) > 0 {
		fmt.Printf("Missing Models: %d\n", len(result.MissingModels))
		for _, model := range result.MissingModels {
			fmt.Printf("  - %s\n", model)
		}
	} else {
		fmt.Println("Missing Models: 0")
	}

	// Field mismatches
	totalMismatches := 0
	for _, mismatches := range result.TableFieldMismatches {
		totalMismatches += len(mismatches)
	}

	if totalMismatches > 0 {
		fmt.Printf("Field Mismatches: %d across %d tables\n", totalMismatches, len(result.TableFieldMismatches))
		for table, mismatches := range result.TableFieldMismatches {
			fmt.Printf("  - %s: %d mismatches\n", table, len(mismatches))
		}
	} else {
		fmt.Println("Field Mismatches: 0")
	}

	// Overall status
	if len(result.MissingTables) == 0 && len(result.MissingModels) == 0 && totalMismatches == 0 {
		fmt.Println("\n✅ SUCCESS: Database schema and Go models are in sync.")
	} else {
		fmt.Println("\n❌ FAILURE: Database schema and Go models are not in sync.")
		fmt.Printf("   See %s for details.\n", "schema_validation_report.md")
	}
}

// buildWrappedModelMap builds a map of model names to model instances
func buildWrappedModelMap() map[string]interface{} {
	modelMap := make(map[string]interface{})

	// Add all models from the models package
	modelMap["LeadGenerationCampaign"] = &models.LeadGenerationCampaign{}
	modelMap["Persona"] = &models.Persona{}
	modelMap["Proxy"] = &models.Proxy{}
	modelMap["KeywordSet"] = &models.KeywordSet{}
	// KeywordRule is embedded in KeywordSet as a JSONB array, not a separate table
	// modelMap["KeywordRule"] = &models.KeywordRule{}
	modelMap["GeneratedDomain"] = &models.GeneratedDomain{}
	modelMap["DNSValidationResult"] = &models.DNSValidationResult{}
	modelMap["HTTPKeywordResult"] = &models.HTTPKeywordResult{}
	modelMap["AuditLog"] = &models.AuditLog{}
	modelMap["CampaignJob"] = &models.CampaignJob{}
	modelMap["DomainGenerationCampaignParams"] = &models.DomainGenerationCampaignParams{}
	modelMap["DNSValidationCampaignParams"] = &models.DNSValidationCampaignParams{}
	modelMap["HTTPKeywordCampaignParams"] = &models.HTTPKeywordCampaignParams{}
	modelMap["DomainGenerationPhaseConfigState"] = &models.DomainGenerationPhaseConfigState{}

	return modelMap
}
