package analyzer

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"mcp/internal/models"
	"os"
	"path/filepath"
	"strings"
)

// ParseGoFiles analyzes Go source files and extracts detailed information
func ParseGoFiles(dir string) ([]models.GoFile, error) {
	var goFiles []models.GoFile

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		goFile := models.GoFile{
			Name:        filepath.Base(path),
			Path:        path,
			Package:     node.Name.Name,
			PackageName: node.Name.Name,
			Functions:   extractFunctions(node),
			Structs:     extractStructs(node),
			Interfaces:  extractInterfaces(node),
			Imports:     extractImports(node),
			Types:       extractTypes(node),
		}

		goFiles = append(goFiles, goFile)
		return nil
	})

	return goFiles, err
}

// extractFunctions extracts function names from AST
func extractFunctions(node *ast.File) []string {
	var functions []string

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.FuncDecl:
			if x.Name != nil {
				funcName := x.Name.Name
				if x.Recv != nil && len(x.Recv.List) > 0 {
					// Method - include receiver type
					if len(x.Recv.List) > 0 {
						if starExpr, ok := x.Recv.List[0].Type.(*ast.StarExpr); ok {
							if ident, ok := starExpr.X.(*ast.Ident); ok {
								funcName = fmt.Sprintf("(%s) %s", ident.Name, funcName)
							}
						} else if ident, ok := x.Recv.List[0].Type.(*ast.Ident); ok {
							funcName = fmt.Sprintf("(%s) %s", ident.Name, funcName)
						}
					}
				}
				functions = append(functions, funcName)
			}
		}
		return true
	})

	return functions
}

// extractStructs extracts struct names from AST
func extractStructs(node *ast.File) []string {
	var structs []string

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := typeSpec.Type.(*ast.StructType); ok {
							structs = append(structs, typeSpec.Name.Name)
						}
					}
				}
			}
		}
		return true
	})

	return structs
}

// extractInterfaces extracts interface names from AST
func extractInterfaces(node *ast.File) []string {
	var interfaces []string

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if _, ok := typeSpec.Type.(*ast.InterfaceType); ok {
							interfaces = append(interfaces, typeSpec.Name.Name)
						}
					}
				}
			}
		}
		return true
	})

	return interfaces
}

// extractImports extracts import paths from AST
func extractImports(node *ast.File) []string {
	var imports []string

	for _, imp := range node.Imports {
		if imp.Path != nil {
			importPath := strings.Trim(imp.Path.Value, "\"")
			imports = append(imports, importPath)
		}
	}

	return imports
}

// extractTypes extracts all type names from AST
func extractTypes(node *ast.File) []string {
	var types []string

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						types = append(types, typeSpec.Name.Name)
					}
				}
			}
		}
		return true
	})

	return types
}

// ParseGinRoutes analyzes Go files to extract Gin routes
func ParseGinRoutes(filePath string) ([]models.Route, error) {
	var routes []models.Route

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	ast.Inspect(node, func(n ast.Node) bool {
		if callExpr, ok := n.(*ast.CallExpr); ok {
			if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
				// Look for router.GET, router.POST, etc.
				method := selExpr.Sel.Name
				if isHTTPMethod(method) && len(callExpr.Args) >= 2 {
					// First argument should be the path
					if pathLit, ok := callExpr.Args[0].(*ast.BasicLit); ok {
						path := strings.Trim(pathLit.Value, "\"")

						// Second argument should be the handler
						var handler string
						if ident, ok := callExpr.Args[1].(*ast.Ident); ok {
							handler = ident.Name
						} else if selExpr, ok := callExpr.Args[1].(*ast.SelectorExpr); ok {
							handler = selExpr.Sel.Name
						}

						routes = append(routes, models.Route{
							Method:  strings.ToUpper(method),
							Path:    path,
							Handler: handler,
						})
					}
				}
			}
		}
		return true
	})

	return routes, nil
}

// isHTTPMethod checks if a string is an HTTP method
func isHTTPMethod(method string) bool {
	httpMethods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"}
	method = strings.ToUpper(method)
	for _, m := range httpMethods {
		if m == method {
			return true
		}
	}
	return false
}

// GetValidationRules analyzes code for validation patterns
func GetValidationRules(dir string) ([]models.ValidationRule, error) {
	var rules []models.ValidationRule

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		lines := strings.Split(string(content), "\n")
		for i, line := range lines {
			// Look for struct tags with validation
			if strings.Contains(line, `validate:"`) {
				start := strings.Index(line, `validate:"`) + 10
				end := strings.Index(line[start:], `"`)
				if end > 0 {
					validation := line[start : start+end]

					// Extract field name (simple heuristic)
					words := strings.Fields(line)
					var fieldName string
					if len(words) > 0 {
						fieldName = words[0]
					}

					rules = append(rules, models.ValidationRule{
						Field:       fieldName,
						Rule:        validation,
						Message:     fmt.Sprintf("Validation rule: %s", validation),
						File:        path,
						LineNumber:  i + 1,
						Name:        fmt.Sprintf("Validation for %s", fieldName),
						Description: fmt.Sprintf("Field %s must satisfy: %s", fieldName, validation),
						Pattern:     fmt.Sprintf(`validate:"%s"`, validation),
						Severity:    getSeverity(validation),
					})
				}
			}
		}

		return nil
	})

	return rules, err
}

// getSeverity determines severity based on validation rule
func getSeverity(rule string) string {
	if strings.Contains(rule, "required") {
		return "error"
	}
	if strings.Contains(rule, "email") || strings.Contains(rule, "url") {
		return "error"
	}
	return "warning"
}

// GetErrorHandlers analyzes code for error handling patterns
func GetErrorHandlers(dir string) ([]models.ErrorHandler, error) {
	var handlers []models.ErrorHandler

	// Common error handling patterns
	patterns := []struct {
		name        string
		pattern     string
		description string
	}{
		{"HTTP Error Handler", "func.*Error.*http\\.ResponseWriter", "HTTP error response handler"},
		{"Database Error Handler", "if err != nil.*database", "Database error handling"},
		{"Validation Error Handler", "if.*valid.*error", "Input validation error handling"},
		{"Generic Error Handler", "if err != nil", "Generic error handling pattern"},
	}

	for _, p := range patterns {
		handlers = append(handlers, models.ErrorHandler{
			Name:        p.name,
			Type:        "pattern",
			File:        dir,
			Description: p.description,
			Pattern:     p.pattern,
			Location:    fmt.Sprintf("%s/*", dir),
		})
	}

	return handlers, nil
}

// GetSecurityPolicies analyzes code for security policies
func GetSecurityPolicies(dir string) ([]models.SecurityPolicy, error) {
	var policies []models.SecurityPolicy

	// Common security patterns
	securityPatterns := []struct {
		name        string
		pattern     string
		description string
	}{
		{"Authentication Middleware", "func.*Auth.*middleware", "Authentication middleware"},
		{"CORS Policy", "cors\\.New", "CORS configuration"},
		{"Rate Limiting", "rate.*limit", "Rate limiting implementation"},
		{"Input Sanitization", "sanitize|escape", "Input sanitization"},
	}

	for _, p := range securityPatterns {
		policies = append(policies, models.SecurityPolicy{
			Name:        p.name,
			Type:        "middleware",
			Rules:       []string{p.pattern},
			File:        dir,
			Enabled:     true,
			Description: p.description,
			Pattern:     p.pattern,
			Location:    fmt.Sprintf("%s/*", dir),
		})
	}

	return policies, nil
}

// GetPerformanceMetrics analyzes code for performance metrics
func GetPerformanceMetrics(dir string) ([]models.PerformanceMetrics, error) {
	var metrics []models.PerformanceMetrics

	// Example performance metrics - in practice, these would be extracted from monitoring
	metrics = append(metrics, models.PerformanceMetrics{
		Name:         "API Response Time",
		Value:        "145ms",
		Threshold:    "200ms",
		Status:       "Good",
		Description:  "Average API response time",
		ResponseTime: 145.0,
		Type:         "timing",
		File:         dir,
		Pattern:      "response_time_*",
		Location:     fmt.Sprintf("%s/handlers", dir),
	})

	metrics = append(metrics, models.PerformanceMetrics{
		Name:         "Database Query Time",
		Value:        "23ms",
		Threshold:    "50ms",
		Status:       "Excellent",
		Description:  "Average database query execution time",
		ResponseTime: 23.0,
		Type:         "database",
		File:         dir,
		Pattern:      "db_query_*",
		Location:     fmt.Sprintf("%s/database", dir),
	})

	return metrics, nil
}

// GetAuditLogs analyzes code for audit logging patterns
func GetAuditLogs(dir string) ([]models.AuditLog, error) {
	var logs []models.AuditLog

	// Example audit logs - in practice, these would be extracted from log files
	logs = append(logs, models.AuditLog{
		ID:          "audit_001",
		Timestamp:   "2025-06-24T14:15:00Z",
		Action:      "User Login",
		User:        "user123",
		Resource:    "/api/auth/login",
		Details:     "Successful user authentication",
		Name:        "Login Audit",
		Type:        "authentication",
		File:        fmt.Sprintf("%s/auth.log", dir),
		Description: "User authentication audit log",
		Pattern:     "auth_*",
		Location:    fmt.Sprintf("%s/logs", dir),
	})

	return logs, nil
}

// ParseHandlers analyzes Go files to extract handler functions
func ParseHandlers(dirPath string) ([]models.Handler, error) {
	var handlers []models.Handler

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		ast.Inspect(node, func(n ast.Node) bool {
			if fn, ok := n.(*ast.FuncDecl); ok && fn.Name != nil {
				// Look for handler functions (functions that take http.ResponseWriter)
				if fn.Type.Params != nil {
					for _, param := range fn.Type.Params.List {
						if selExpr, ok := param.Type.(*ast.SelectorExpr); ok {
							if selExpr.Sel.Name == "ResponseWriter" {
								handlers = append(handlers, models.Handler{
									Name: fn.Name.Name,
									File: path,
								})
								break
							}
						}
					}
				}
			}
			return true
		})

		return nil
	})

	return handlers, err
}

// ParseServices analyzes Go files to extract service definitions
func ParseServices(dirPath string) ([]models.Service, error) {
	var services []models.Service

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		// Look for struct types that might be services
		ast.Inspect(node, func(n ast.Node) bool {
			if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							// Check if it has methods (service-like)
							serviceName := typeSpec.Name.Name
							if strings.HasSuffix(serviceName, "Service") ||
								strings.HasSuffix(serviceName, "Handler") ||
								strings.HasSuffix(serviceName, "Manager") {

								methods := extractMethodsForType(node, serviceName)
								services = append(services, models.Service{
									Name:      serviceName,
									File:      path,
									Methods:   methods,
									Interface: "",
								})
							}
							_ = structType // Mark as used
						}
					}
				}
			}
			return true
		})

		return nil
	})

	return services, err
}

// extractMethodsForType finds methods for a given type
func extractMethodsForType(node *ast.File, typeName string) []string {
	var methods []string

	ast.Inspect(node, func(n ast.Node) bool {
		if fn, ok := n.(*ast.FuncDecl); ok && fn.Name != nil && fn.Recv != nil {
			// Check if this is a method for our type
			for _, recv := range fn.Recv.List {
				var recvType string
				if starExpr, ok := recv.Type.(*ast.StarExpr); ok {
					if ident, ok := starExpr.X.(*ast.Ident); ok {
						recvType = ident.Name
					}
				} else if ident, ok := recv.Type.(*ast.Ident); ok {
					recvType = ident.Name
				}

				if recvType == typeName {
					methods = append(methods, fn.Name.Name)
				}
			}
		}
		return true
	})

	return methods
}

// GetInterfaces analyzes Go files to extract interface definitions
func GetInterfaces(dirPath string) ([]models.InterfaceDefinition, error) {
	var interfaces []models.InterfaceDefinition

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		ast.Inspect(node, func(n ast.Node) bool {
			if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if interfaceType, ok := typeSpec.Type.(*ast.InterfaceType); ok {
							methods := extractInterfaceMethods(interfaceType)
							interfaces = append(interfaces, models.InterfaceDefinition{
								Name:    typeSpec.Name.Name,
								File:    path,
								Methods: methods,
							})
						}
					}
				}
			}
			return true
		})

		return nil
	})

	return interfaces, err
}

// extractInterfaceMethods extracts method names from an interface type
func extractInterfaceMethods(interfaceType *ast.InterfaceType) []string {
	var methods []string

	for _, method := range interfaceType.Methods.List {
		if len(method.Names) > 0 {
			methods = append(methods, method.Names[0].Name)
		}
	}

	return methods
}

// FindImplementations finds types that implement a given interface
func FindImplementations(dirPath string, interfaceName string) ([]models.Implementation, error) {
	var implementations []models.Implementation

	// First, get the interface definition
	interfaces, err := GetInterfaces(dirPath)
	if err != nil {
		return nil, err
	}

	var targetInterface *models.InterfaceDefinition
	for _, iface := range interfaces {
		if iface.Name == interfaceName {
			targetInterface = &iface
			break
		}
	}

	if targetInterface == nil {
		return implementations, nil // Interface not found
	}

	// Find types that implement all methods of the interface
	services, err := ParseServices(dirPath)
	if err != nil {
		return nil, err
	}

	for _, service := range services {
		if implementsInterface(service.Methods, targetInterface.Methods) {
			implementations = append(implementations, models.Implementation{
				TypeName:      service.Name,
				InterfaceName: interfaceName,
				File:          service.File,
			})
		}
	}

	return implementations, nil
}

// implementsInterface checks if a type implements all methods of an interface
func implementsInterface(typeMethods, interfaceMethods []string) bool {
	for _, ifaceMethod := range interfaceMethods {
		found := false
		for _, typeMethod := range typeMethods {
			if typeMethod == ifaceMethod {
				found = true
				break
			}
		}
		if !found {
			return false
		}
	}
	return len(interfaceMethods) > 0 // Must have at least one method to implement
}

// GetCallGraph analyzes function calls to build a call graph
func GetCallGraph(dirPath string, functionName string) (models.CallGraphNode, error) {
	var callGraph models.CallGraphNode
	callGraph.FunctionName = functionName
	callGraph.Calls = []string{}

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		// Find the target function
		ast.Inspect(node, func(n ast.Node) bool {
			if fn, ok := n.(*ast.FuncDecl); ok && fn.Name != nil && fn.Name.Name == functionName {
				callGraph.Package = node.Name.Name
				callGraph.File = path

				// Find all function calls within this function
				ast.Inspect(fn, func(innerNode ast.Node) bool {
					if callExpr, ok := innerNode.(*ast.CallExpr); ok {
						if ident, ok := callExpr.Fun.(*ast.Ident); ok {
							callGraph.Calls = append(callGraph.Calls, ident.Name)
						} else if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
							callGraph.Calls = append(callGraph.Calls, selExpr.Sel.Name)
						}
					}
					return true
				})
			}
			return true
		})

		return nil
	})

	callGraph.CallCount = len(callGraph.Calls)
	return callGraph, err
}

// ParseConfig analyzes Go files to extract configuration fields
func ParseConfig(dirPath string) ([]models.ConfigField, error) {
	var configFields []models.ConfigField

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		ast.Inspect(node, func(n ast.Node) bool {
			if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.TYPE {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if structType, ok := typeSpec.Type.(*ast.StructType); ok {
							// Look for config-like structs
							structName := typeSpec.Name.Name
							if strings.Contains(strings.ToLower(structName), "config") {
								fields := extractStructFields(structType)
								configFields = append(configFields, fields...)
							}
						}
					}
				}
			}
			return true
		})

		return nil
	})

	return configFields, err
}

// extractStructFields extracts fields from a struct type
func extractStructFields(structType *ast.StructType) []models.ConfigField {
	var fields []models.ConfigField

	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			fieldType := getTypeString(field.Type)
			jsonTag := getJSONTag(field.Tag)

			fields = append(fields, models.ConfigField{
				Name:    name.Name,
				Type:    fieldType,
				JSONTag: jsonTag,
			})
		}
	}

	return fields
}

// getTypeString converts an ast.Expr to a type string
func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return getTypeString(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeString(t.Elt)
	default:
		return "unknown"
	}
}

// getJSONTag extracts JSON tag from struct field tag
func getJSONTag(tag *ast.BasicLit) string {
	if tag == nil {
		return ""
	}

	tagStr := strings.Trim(tag.Value, "`")
	if strings.Contains(tagStr, "json:") {
		start := strings.Index(tagStr, "json:\"") + 6
		if start > 5 {
			end := strings.Index(tagStr[start:], "\"")
			if end > 0 {
				return tagStr[start : start+end]
			}
		}
	}

	return ""
}

// FindByType finds references to a specific type
func FindByType(dirPath string, typeName string) ([]models.Reference, error) {
	var references []models.Reference

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		ast.Inspect(node, func(n ast.Node) bool {
			// Look for type usage in various contexts
			switch x := n.(type) {
			case *ast.Ident:
				if x.Name == typeName {
					pos := fset.Position(x.Pos())
					references = append(references, models.Reference{
						Name: typeName,
						File: path,
						Line: pos.Line,
						Type: "identifier",
					})
				}
			case *ast.SelectorExpr:
				if x.Sel.Name == typeName {
					pos := fset.Position(x.Sel.Pos())
					references = append(references, models.Reference{
						Name: typeName,
						File: path,
						Line: pos.Line,
						Type: "selector",
					})
				}
			}
			return true
		})

		return nil
	})

	return references, err
}

// AnalyzeWorkflows analyzes code for workflow patterns
func AnalyzeWorkflows(dirPath string) ([]models.Workflow, error) {
	var workflows []models.Workflow

	// Look for common workflow patterns
	workflowPatterns := []struct {
		name        string
		pattern     string
		description string
	}{
		{"State Machine", "switch.*state", "State machine workflow pattern"},
		{"Pipeline", "pipe|chain|flow", "Pipeline processing workflow"},
		{"Event Handler", "handle.*event|on.*event", "Event-driven workflow"},
		{"Job Queue", "queue|job|task", "Job queue workflow pattern"},
	}

	for i, pattern := range workflowPatterns {
		workflows = append(workflows, models.Workflow{
			ID:          fmt.Sprintf("workflow_%d", i+1),
			Name:        pattern.name,
			Description: pattern.description,
			Steps:       []string{"analyze", "process", "complete"},
			Status:      "active",
		})
	}

	return workflows, nil
}

// AnalyzeBusinessRules analyzes code for business rule patterns
func AnalyzeBusinessRules(dirPath string) ([]models.BusinessRule, error) {
	var rules []models.BusinessRule

	// Look for common business rule patterns
	rulePatterns := []struct {
		name        string
		condition   string
		action      string
		description string
	}{
		{"Validation Rule", "validate", "reject|accept", "Input validation business rule"},
		{"Authorization Rule", "auth|permission", "allow|deny", "Authorization business rule"},
		{"Business Logic", "calculate|compute", "return|set", "Business calculation rule"},
		{"Workflow Rule", "if.*then|when.*do", "execute|trigger", "Conditional workflow rule"},
	}

	for i, pattern := range rulePatterns {
		rules = append(rules, models.BusinessRule{
			ID:          fmt.Sprintf("rule_%d", i+1),
			Name:        pattern.name,
			Description: pattern.description,
			Condition:   pattern.condition,
			Action:      pattern.action,
			Priority:    1,
			Enabled:     true,
		})
	}

	return rules, nil
}

// AnalyzeFeatureFlags analyzes code for feature flag patterns
func AnalyzeFeatureFlags(dirPath string) ([]models.FeatureFlag, error) {
	var flags []models.FeatureFlag

	err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".go") {
			return err
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		lines := strings.Split(string(content), "\n")
		for i, line := range lines {
			// Look for feature flag patterns
			if strings.Contains(strings.ToLower(line), "feature") &&
				(strings.Contains(strings.ToLower(line), "flag") ||
					strings.Contains(strings.ToLower(line), "toggle") ||
					strings.Contains(strings.ToLower(line), "enable")) {

				flagName := extractFlagName(line)
				if flagName != "" {
					flags = append(flags, models.FeatureFlag{
						Name:        flagName,
						Description: fmt.Sprintf("Feature flag found in %s", filepath.Base(path)),
						Enabled:     true,
						File:        path,
						Line:        i + 1,
					})
				}
			}
		}

		return nil
	})

	return flags, err
}

// extractFlagName extracts flag name from a line of code
func extractFlagName(line string) string {
	// Simple heuristic to extract flag names
	words := strings.Fields(line)
	for _, word := range words {
		if strings.Contains(strings.ToLower(word), "flag") ||
			strings.Contains(strings.ToLower(word), "feature") {
			// Clean up the word
			word = strings.Trim(word, "\"'(){}[];,.")
			if len(word) > 3 {
				return word
			}
		}
	}
	return ""
}
